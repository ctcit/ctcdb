<?php  if (!defined('BASEPATH')) exit('No direct script access allowed');

class Ctcmodel extends CI_Model
// The 'model' for the CTC DB. Theoretically, all code that is dependent
// upon the database schema resides in this module, but that rapidly became
// impracticable for the various queries and is totally dispensed with in
// the case of the User/System SQL queries. However, all actual queries should
// at least pass through this module and it is very important at least to
// ensure that all updates are done from within this module.

// This module also converts all non-admin dates to/from MySQL YYYY-MM-DD format in
// the database to NZ DD-MM-YYYY format for use by all code outside this
// module. The exception is the query module which does its own querying
// and so is responsible for any date format changes. Also, the resignationDateAdmin
// field, being nominally tagged as 'Admin' must be handled outside.

// TODO consider transaction locking for multi-record updates.
// TODO figure out what's needed to deal with timezones correctly.
{
    function Ctcmodel()
    {
        // Call the Model constructor
        parent::__construct();
        $this->load->helper('date');
        $this->MAX_NUM_RESULTS = 20;  // The max number of query results to store
        $CI = & get_instance();
}

    // DATABASE INSERTION AND UPDATE FUNCTIONS
    // =======================================

    function insertMember()
    // Creates a new entry in the Members and Memberships tables using all the data in the current
    // $_POST form, which is assumed to contain all the fields generated by the getNewMemberData function.
    // Returns the membershipId of the new member or False if something blows up.
    // Sends a welcome-to-the-club email, unless it's a prospective.
    {
        global $userData;
        $result = true;
        $memberFields = $this->db->list_fields('members');
        $membershipFields = $this->db->list_fields('memberships');
        $memberData = $this->getFieldsFromPost($memberFields, false);
        $membershipData = $this->getFieldsFromPost($membershipFields, false);
        $membershipType = $this->input->post('membershipTypeEnum');
        return $this->insertMember2($membershipType, $memberData, $membershipData);
    }

    function insertMember2($membershipType, $memberData, $membershipData=NULL)
    // Phase 2 of the member insertion sequence. The various fields for the
    // new membership must be in the $memberData and $membershipData fields.
    // If the latter is null, the new member is assumed to be part of a couple
    // where the membership row has already been added. The $memberData array
    // should then have a defined $memberData['membershipId'] field.
    {
        global $userData;
        if ($membershipData != NULL) {
            if ($membershipType == 'Prospective') {
                $membershipData['statusAdmin'] = 'Pending';
            }
            else {
                $membershipData['statusAdmin'] = 'Active';
            }
            $membershipId = $this->insertMembership($membershipType, $membershipData);
            if ($membershipId === false) {
                return false;
            }
            $memberData['membershipId'] = $membershipId;
        }

        assert(isset($memberData['membershipId']));

        if (isset($memberData['dateJoined'])) {
            $memberData['dateJoined'] = date_to_mysql($memberData['dateJoined']);
        }
        else {
            $memberData['dateJoined'] = date("Y-m-d");
        }
        $memberData['userIdAdmin'] = $userData['userid'];
        $loginName = $memberData['loginName'];
        $pass = $this->generatePassword($loginName);
        $memberData['joomlaPasswordAdmin'] = $this->hashPassword($pass);
        $this->db->set($memberData);
        $this->db->insert('members');
        // $id = $this->db->insert_id();
        if ($membershipType != 'Prospective') {
            $this->sendWelcomeEmail($loginName, $pass);
        }
        return $memberData['membershipId'];
    }

    function insertCouple()
    // Creates two new entries in the Members table and one new Membership entry using
    // all the data in the current $_POST form.
    // TODO: Allow insertion of AssociateCouple memberships.
    {
        $membershipFields = $this->db->list_fields('memberships');
        $membershipData = $this->getFieldsFromPost($membershipFields, false);
        $memberFields = $this->db->list_fields('members');
        $memberData1 = $this->getFieldsFromPost($memberFields, false, "__1");
        $membershipId = $this->insertMember2("Couple", $memberData1, $membershipData);
        if ($membershipId === false) {
            return false;
        }

        $memberData2 = $this->getFieldsFromPost($memberFields, false, "__2");
        $memberData2['membershipId'] = $membershipId;
        return $this->insertMember2('Couple', $memberData2);
    }

    function updateMember($id, $isProfileUpdate = false)
    // Writes all the data in the current $_POST form, which is assumed to be from a
    // memberUpdate or profileUpdate form, to the database (both members and memberships tables).
    // $isProfileUpdate is true if the update is from a profile update,
    // which permits only a restricted subset of fields to be updated.
    // Also records, in the member_updates and membership_updates, any columns that
    // changed.
    // Returns an associative array of all changes: key is the field name,
    // value is a 2-element array containing the old value and the new
    // value. Returns an empty array if no actual changes took place,
    // null if there was a fatal error of some sort (currently unimplemented).
    {
        $changes = array();
        if (isset($_POST['dateJoined'])) {
            $_POST['dateJoined'] = date_to_mysql($this->input->post('dateJoined', True));
        }
        $memberFields = $isProfileUpdate ? $this->getMemberProfileFields() : $this->getMemberFields();
        $getQuery = "select " . implode(',', $memberFields ) . " from members where id = $id";
        $query = $this->db->query($getQuery);
        $row = $query->row_array();
        foreach ($memberFields as $field) {
            $newValue = $this->input->post($field, True);
            if ($newValue != $row[$field]) {
                $oldValue = $row[$field];
                if ($oldValue == NULL) $oldValue = 'NULL';
                $this->recordMemberUpdate($id, $field, $oldValue, $newValue);
                $changes[$field] = array($oldValue, $newValue);
            }
        }
        $this->updateTableFromPost('members', $id, $memberFields);
        $membershipId = $this->getMembershipId($id);
        if ($isProfileUpdate) {
            $membershipFields = $this->getMembershipProfileFields();
        }
        else {
            $membershipFields = $this->getMembershipFields();
            array_push($membershipFields, 'membershipTypeEnum');
        }

        $getQuery = "select " . implode(',', $membershipFields ) .
                " from memberships, membership_types where memberships.id = $membershipId and membershipTypeId = membership_types.id";
        $query = $this->db->query($getQuery);
        $row = $query->row_array();
        foreach ($membershipFields as $field) {
            $newValue = $this->input->post($field, True);
            if ($newValue != $row[$field]) {
                $oldValue = $row[$field];
                if ($oldValue == NULL) $oldValue = 'NULL';
                if ($field == 'membershipTypeEnum' && $oldValue == 'Prospective' && $oldValue != $newValue ) {
                    // Activate membership of a prospective who changes to any other membership type
                    // TODO: Test drive this prospective membership change code
                    array_push($membershipFields, 'statusAdmin');
                    $_POST['statusAdmin'] = 'Active';
                    $loginName = $this->input->post('loginName');
                    $pass = $this->generatePassword($loginName);
                    $this->setMemberPasswordRaw($id, $pass);
                    $this->sendWelcomeEmail($loginName, $pass);
                }
                $this->recordMembershipUpdate($membershipId, $field, $oldValue, $newValue);
                $changes[$field] = array($oldValue, $newValue);
                if ($field == 'membershipTypeEnum') {  // Change of membership type?
                    $newId = $this->getMembershipTypeId($newValue);
                    array_push($membershipFields, 'membershipTypeId');
                    $_POST['membershipTypeId'] = $newId;
                }
            }
        }

        $membershipFields = array_diff($membershipFields, array('membershipTypeEnum'));
        $this->updateTableFromPost('memberships', $membershipId, $membershipFields);
        return $changes;
    }

    function coupleMembers($id1, $id2, $membershipFields)
    // Close the memberships for the two given members and open a new 'Couple' one
    // by cloning the data from $id1, replacing fields with data given
    // in $membershipFields when this is non-null. The links from members to the two
    // now defunct memberships table entries are recorded in the members_memberships table
    // and the members themselves are linked to the new memberships entry.
    // Return true if successful.
    // TODO: Allow for possibility of a coupling generating an AssociateCouple.
    {
        // Validate the new members IDs and current status/type.

        $member1Data = $this->getMembershipDataByMemberId($id1);
        $member2Data = $this->getMembershipDataByMemberId($id2);
        if (strpos($member1Data['membershipTypeEnum'] . $member2Data['membershipTypeEnum'], 'Couple') !== FALSE ) {
            return false;  // Neither of existing memberships can be a couple type
        }

        // Extract all the data from the first membership and the given form data
        // to build a new membership entry

        $membershipId1 = $member1Data['membershipId'];
        $membershipId2 = $member2Data['membershipId'];
        $newMembership = array();

        $dontCopy = array('membershipId', 'membershipTypeEnum','statusAdmin');
        foreach (array_keys($member1Data) as $key) {
            if (!in_array($key, $dontCopy)) {
                if ($membershipFields[$key] != '') {
                    $newMembership[$key] = $membershipFields[$key];  // Use form data if given
                }
                else {
                    $newMembership[$key] = $member1Data[$key];   // Else copy from member 1
                }
            }
        }

        // Close off the two existing memberships records and record the defunct
        // linkages in members_memberships

        $this->db->query("UPDATE memberships ".
                         "SET dateClosedAdmin=now(), statusAdmin = 'Coupled' ".
                         "WHERE id = $membershipId1 OR id = $membershipId2");
        if ($this->db->affected_rows() != 2) {
            return false;
        }
        $this->db->insert('members_memberships', array('memberId'=>$id1, 'membershipId'=>$membershipId1));
        $this->db->insert('members_memberships', array('memberId'=>$id2, 'membershipId'=>$membershipId2));

        // Insert the new memberships row and link the two members to it

        $newMembershipId = $this->insertMembership('Couple', $newMembership);
        $this->db->update('members', array('membershipId'=>$newMembershipId), "id = $id1 or id = $id2");
        if ($this->db->affected_rows() != 2) {
            return false;
        }

        return true;  // Optimism!
    }

    function decouple($membershipId)
    // Decouple the given couple membership into two new separate
    // membership, each a copy of the couple membership (but with the
    // membership name, membership email and all administrative fields cleared).
    {
        $query = $this->db->get_where('memberships', array('id'=>$membershipId));
        $row = $query->row_array();
        $ids = $this->getMemberIds($membershipId);
        if ($ids == NULL || count($ids) != 2) {
            return false;
        }
        $id1 = $ids[0];
        $id2 = $ids[1];
        $this->db->query(
            "update memberships set dateClosedAdmin=now(), statusAdmin='Decoupled' where id = $membershipId");
        if ($this->db->affected_rows() != 1) { return false; }
        // Record the two defunct linkages
        $this->db->insert('members_memberships',array('memberId' => $id1, 'membershipId' => $membershipId));
        $this->db->insert('members_memberships',array('memberId' => $id2, 'membershipId' => $membershipId));

        // Build a new membership record to use for each of the new members

        $suppressFields = array('membershipMailName', 'membershipEmail');  // Fields we don't wish to copy to new members
        $membershipFields = $this->getMembershipFields();
        foreach ($membershipFields as $field) {         // Copy fields across unless suppressed
            if (!in_array($field, $suppressFields)) {
                $newMembership[$field] = $row[$field];
            }
        }

        // Insert the new membership twice and link the members to it.

        $newMembershipId1 = $this->insertMembership('Ordinary', $newMembership);
        $newMembershipId2 = $this->insertMembership('Ordinary', $newMembership);
        $this->db->update('members', array('membershipId' => $newMembershipId1), "id = $id1");
        if ($this->db->affected_rows() != 1) {
            return False;
        }
        $this->db->update('members', array('membershipId' => $newMembershipId2), "id = $id2");
        if ($this->db->affected_rows() != 1) {
            return False;
        }
        return True;
    }

    function closeMembership($membershipId, $reason, $resignationDate, $notes)
    // Close the given membership record. The reason must be one of the enum values
    // for closing a membership.
    // The resignationDate parameter should be in
    // NZ format. The $notes field is the original membership notes field but perhaps
    // with additional info added on the reason for the closure. See ctc->closeMembership().
    {
        $resignationDateMysql = date_to_mysql($resignationDate);
        $status = $this->getMembershipStatusByMembershipId($membershipId);
        assert($status == 'Active');
        echo "Date = ".date('Y-m-d');
        $this->db->where('id', $membershipId);
        $this->db->update("memberships",
            array('statusAdmin' => $reason,
                'dateClosedAdmin' => date('Y-m-d H:i:s'),
                'resignationDateAdmin' => $resignationDateMysql,
                'membershipNotes' => $notes)
        );
        $ok = $this->db->affected_rows() == 1;
        $this->recordMembershipUpdate($membershipId, 'statusAdmin', $status, $reason);
        return $ok;
    }


    function reinstateMembership($membershipId)
    {
        $status = $this->getMembershipStatusByMembershipId($membershipId);
        $this->db->query(
            "update memberships set statusAdmin='Active', dateClosedAdmin=NULL where id = $membershipId");
        $ok = $this->db->affected_rows() == 1;
        $this->recordMembershipUpdate($membershipId, 'statusAdmin', $status, 'Active', 'Reinstated');
        return $ok;
    }

    function rejoinMember($memberId)
    // Construct a new membership for the given member (assumed to have a closed membership).
    // Copy the address from the old membership, which becomes defunct and is linked
    // to the member only via a new members-memberships table entry.
    {
        $data = $this->getMemberDataByMemberId($memberId);
        // Record the defunct membership
        $this->db->insert('members_memberships',array('memberId' => $memberId, 'membershipId' => $data['membershipId']));
        $data = array(
            'address1' => $data['address1'],
            'address2' => $data['address2'],
            'city' => $data['city'],
            'postcode' => $data['postcode']);
        $membershipId = $this->insertMembership('Ordinary', $data);
        $this->db->update('members',array('membershipId'=>$membershipId), "id = $memberId");
        $ok = $this->db->affected_rows() == 1;
        return $ok;
    }

    function saveQuery($id, $name, $description, $query, $userId)
    // Replace the query having the given $id with the new name and value,
    // or insert a new query if $id == 0.
    // Returns true iff update affected exactly one row.
    {
        $query = addslashes($query);
        $description = addslashes($description);
        if ($id == 0) {
            $this->db->query("insert into user_queries
             (name, description, sqlquery, userIdAdmin) values
             ('$name', '$description', '$query', '$userId')");
        }
        else {
            $this->db->query("update user_queries set name='$name',
                description='$description', sqlquery='$query',
                userIdAdmin='$userId' where id=$id");
        }
        return $this->db->affected_rows() == 1;
    }

    function deleteQuery($id)
    {
        $this->db->query("delete from user_queries where id = $id");
    }


    function deleteSavedResult($id)
    {
        $this->db->where('id', $id);
        $this->db->delete('saved_query_results');
    }

    function saveResult($query) {
        // Record in the saved_query_results table the result of a particular query.
        // Returns the ID of this particular query. The saved_query_results table is configured
        // to hold only a certain number of recent queries (currently 20) so an attempt
        // to retrieve the query result in the future is not totally guaranteed to succeed.

        // Why do I have to use base64_encode/decode in this? I'm not sure but it doesn't
        // work if I don't. There's lots of discussion on php.net/unserialize but most people
        // there seem as confused as me or more so.
        $result = array();
        foreach ($query->result() as $row) {
            $result[] = $row;
        }
        $data = base64_encode(serialize($result));
        $this->db->insert("saved_query_results", array('result' => $data));
        $id = $this->db->insert_id();
        $max = $this->MAX_NUM_RESULTS;
        $rem = $id % $max;
        $this->db->query("DELETE from saved_query_results WHERE (mod(id,$max) = $rem) and (id <> $id)");
        return $id;
    }

    function addOrAlterPayment($membershipId, $data, $year)
    // Add a row to the subs_payments table for the given membership and year, or change
    // the details if such a payment already exists.
    {
        global $userData;
        $where = array('membershipID' => $membershipId, 'subscriptionYear'=>$year,'deletedBoolAdmin'=>0);
        if (isset($data['paymentDate'])) {
            $data['paymentDate'] = date_to_mysql($data['paymentDate']);
        }
        $query = $this->db->get_where('subs_payments',$where);
        if ($query->num_rows() == 0) {  // New payment?
            $data['userIdAdmin'] = $userData['userid'];
            $this->db->insert('subs_payments', array_merge($where, $data));
        }
        else {  // Case where a payment is being altered
            // Firstly find all altered fields and record them in subs_payments_updates
            $row = $query->row_array();
            $subsPaymentsId = $row['id'];
            $subsFields = $this->filterNonModifiable($this->db->list_fields('subs_payments'));
            foreach ($subsFields as $field) {
                if (isset($data[$field]) && $data[$field] != $row[$field]) {
                    $oldValue = $row[$field];
                    if ($oldValue == NULL) $oldValue = 'NULL';
                    $this->recordSubsPaymentUpdate($subsPaymentsId, $field, $oldValue, $data[$field]);
                }
            }
            // Lastly, do the actual update.
            $this->db->where($where);
            $this->db->update('subs_payments', $data);
        }

        return $this->db->affected_rows();
    }

    function deletePayment($paymentId)
    // Delete the payment with the given id.
    {
        $this->recordSubsPaymentUpdate($paymentId, 'deletedBoolAdmin', 0, 1);
        $this->db->where(array('id'=>$paymentId));
        $this->db->update('subs_payments', array('deletedBoolAdmin'=>1));
        return $this->db->affected_rows();
    }


    /**
     * Log the sending of a bulk email item.
     * Used by emailMerge.
     * @param unknown_type $email Email address of recipient
     * @param unknown_type $batchId ID of originating batch in email_batch table
     */
    function logEmail($email, $batchId)
    {
        $this->db->insert('email_log',
            array('email'=>$email, 'batchId'=>$batchId));
    }

    // EXTERNAL SCHEMA QUERY FUNCTIONS
    // ===============================

    function getMemberFields()
    // A list of all dbadmin-modifiable member fields
    {
        return $this->filterNonModifiable($this->db->list_fields('members'));
    }

    function getMembershipFields()
    // A list of all dbadmin-modifiable membership fields
    {
        return $this->filterNonModifiable($this->db->list_fields('memberships'));
    }

    function getMemberProfileFields()
    // A list of all member fields that can be modified by the members themselves
    {
        return array('firstName', 'lastName', 'loginName',
            'primaryEmail', 'workPhone', 'mobilePhone',
            'emergencyContactName', 'emergencyContactPhone',
            'onEmailListBool', 'htmlEmailBool');
    }

    function getMembershipProfileFields()
    // A list of all membership fields that can be modified by the members themselves
    {
        return array('homePhone', 'address1', 'address2','city','postcode');
    }

    function getTableFields($table)
    // A list of all fields of the given table
    {
        return $this->db->list_fields($table);
    }

    function getModifiableDataFields()
    /* Return a list of the user-modifiable data fields from the member and membership tables combined.
     * We use the convention that everything except keys (identifiers id), foreign keys (identifiers
     * ending in id) and administrative fields (identifiers ending in Admin) are user-modifiable.
     */
    {
        return array_merge($this->getMemberFields(), $this->getMembershipFields());
    }

    function getMembershipTypes()
    /* Return a list of all membership types */
    {
        $this->db->select('membershipTypeEnum');
        $query = $this->db->get('membership_types');
        $types = array();
        foreach ($query->result() as $row) {
            array_push($types, $row->membershipTypeEnum);
        }
        return $types;
    }

    // EXTERNAL DB QUERY FUNCTIONS
    // ===========================

    function getMemberDataByMemberId($id)
    /* Returns, for member with given id, all the data fields of both the Members and Memberships tables
     * that can be modified during an EditUser action, plus the membershipId, statusAdmin and membershipType
     */
    {
        $this->db->select(implode(',',$this->getModifiableDataFields()) . ',membershipId, statusAdmin, membershipTypeEnum');
        $this->db->from('members, memberships, membership_types');
        $this->db->where("members.id = $id and membershipId = memberships.id and membershipTypeId = membership_types.id");
        $query = $this->db->get();
        $data = $query->row_array();
        $data['dateJoined'] = date_to_nz($data['dateJoined']);
        return $data;
    }

    function getMembershipDataByMemberId($id)
    /* Returns, for member with given id, all the data fields of the Memberships tables
     * that can be modified during an EditUser action, plus the membershipId, statusAdmin and membershipTypeEnum
     */
    {
        $this->db->select(implode(',',$this->getMembershipFields()) . ',membershipId, statusAdmin, membershipTypeEnum');
        $this->db->from('members, memberships, membership_types');
        $this->db->where("members.id = $id and membershipId = memberships.id and membershipTypeId = membership_types.id");
        $query = $this->db->get();
        return $query->row_array();
    }

    function getMembershipDataByMembershipId($msid)
    /* Same as getMembershipDataByMemberId but given membershipId not memberId */
    {
        $this->db->select(implode(',',$this->getMembershipFields()) . ',membershipId, statusAdmin, membershipTypeEnum');
        $this->db->from('members, memberships, membership_types');
        $this->db->where("memberships.id = $msid and membershipTypeId = membership_types.id");
        $query = $this->db->get();
        return $query->row_array();
    }

    function getMembershipStatusByMembershipId($membershipId)
    // The status of a given membership
    {
        $query = $this->db->query("select statusAdmin from memberships where id=$membershipId");
        $result = $query->row();
        return $result->statusAdmin;
    }

    function genericQuery($sql) {
        // Run any arbitrary query and return the DB result object.
        $this->db->query("set time_zone='+12:00'");
        // TODO do this properly! Check what else is affected and include Daylight Savings
        return $this->db->query($sql);
    }

    function getAllMembersForViewEdit()
    // Return a selected subset of the member fields for all members.
    // Returns the raw query result, for use in a "table->generate" command.
    {
        $this->load->helper('url');
        function makeEditLink($id) {
            return anchor("ctc/editParticularMember/$id","Edit");
        }
        return $this->getAllMembersForSelection('makeEditLink',"(statusAdmin='Active' or statusAdmin='Pending')");
    }

    function getAllMembersForPasswordSetting()
    // Return a selected subset of the member fields for all members.
    // Returns the raw query result, for use in a "table->generate" command.
    {
        $this->load->helper('url');
        function makePassLink($id) {
            return anchor("ctc/setParticularMemberPassword/$id","SetPass");
        }
        return $this->getAllMembersForSelection('makePassLink',"(statusAdmin='Active' or statusAdmin='Pending')");
    }

    function getAllMembersForCoupling()
    // Return a selected subset of the member fields for all members.
    // Returns the raw query result, for use in a "table->generate" command.
    {
        function makeCheckbox($id) {
            return "<input type='checkbox' name='cb$id' />";
        }
        return $this->getAllMembersForSelection('makeCheckBox',
            "statusAdmin='Active' AND NOT (membershipTypeEnum like '%Couple')");
    }

    function getAllMembersSql($constraint = "")
    // An sql query (i.e., the text of the query) for all columns for all members with an additional constraint if desired.
    // If given the constraint must begin "and ...."
    {
        $sql = "select " . implode(',', $this->getModifiableDataFields()) .
            ",statusAdmin as 'status', members.id as memberId, memberships.id as membershipId" .
            " from members, memberships, membership_types" .
            " where membershipId = memberships.id and memberships.membershipTypeId = membership_types.id  $constraint order by LastName,FirstName";
        return $sql;
    }

    function getAllActiveMembersSql() {
        return $this->getAllMembersSql("and statusAdmin='Active'");
    }

    // An array of all active members, each element being an object.
    // UNTESTED.
    function getAllActiveMembers() {
        $query = $this->db->query($this->getAllActiveMembersSql());
        return $query->result();
    }

    function getMemberName($memberId)
    // Get the name in firstName lastName form for a given member
    {
        $query = $this->db->query("select concat(firstName,' ', lastName) as Name from members where id = $memberId");
        $row = $query->row();
        return $row->Name;
    }

    function getMemberLoginName($memberId)
    // Get the login name for the given member
    {
        $query = $this->db->query("select loginName from members where id = $memberId");
        $row = $query->row();
        return $row->loginName;
    }

    function getMemberIdFromLogin($login)
    // Get the id of the member with the given login.
    // Returns 0 if no such login
    {
        $query = $this->db->query("select id from members where loginName = $login");
        $row = $query->row();
        return $row->id;
    }


    function getMemberIdFromMobileNum($mob)
    // Gets the id of the member whose mobile matches the given one.
    // Returns zero if mobile can't be found.
    {
        $query = $this->db->query('select id, mobilePhone from members');
        foreach ($query->result() as $row) {
            if ($this->_phoneNumsMatch($mob, $row->mobilePhone)) {
                return $row->id;
            }
        }
        return 0;
    }

    function getMemberPassword($memberId)
    // Get the hashed password for the given member
    {
        $query = $this->db->query("select joomlaPasswordAdmin as password from members where id = $memberId");
        $row = $query->row();
        return $row->password;
    }

    function setMemberPassword($memberId, $newHash)
    // Set the password for the given member to the new value
    {
        $this->db->query("update members set joomlaPasswordAdmin='$newHash' where id = $memberId");
    }

    function setMemberPasswordRaw($memberId, $plainTextPassword)
    // Hash the given password and store it
    {
        $this->setMemberPassword($memberId, $this->hashPassword($plainTextPassword));
    }

    function getMembershipId($memberId)
    {
        $query = $this->db->query(
            "select membershipId from members where id = $memberId");
        $row = $query->row();
        return $row->membershipId;
    }

    function getMemberStatus($memberId)
    // Get the most-recent membership status for a given member
    {
        $query = $this->db->query(
            "select statusAdmin from members, memberships where members.id = $memberId and membershipId = memberships.id");
        $row = $query->row();
        return $row->statusAdmin;
    }

    function getQueryOwningMembers()
    // Return an associative array of memberId=>loginName for all members who either
    // own SQL queries already or are club officers (in the sense that they
    // appear in Joomla's contacts table).
    // This is intended solely for use in displaying a list of query owners to
    // the webmaster when editing queries. See queries.php and showQueries.php.
    {
        $query = $this->db->query("(SELECT DISTINCT loginName as user, members.id as id"
                    ."\n FROM user_queries, members "
                    ."\n WHERE members.id = user_queries.userIdAdmin)"
                    ."\n UNION (SELECT DISTINCT loginName as user, members.id as id"
                    ."\n        FROM members, ctcweb9_joom1.jos_contact_details AS contacts"
                    ."\n        WHERE members.id = contacts.user_id)"
                    ."\n        ORDER BY user");
        $rows = $query->result_array();
        $result = array();
        foreach ($rows as $row) {
            $result[$row['id']] = $row['user'];
        }
        return $result;
    }

    function getMembershipName($membershipId)
    // Gets the name to use for mailing to a given membership. This is:
    // (1) The membershipMailName field from the memberships table, if non-NULL, or
    // (2) The concat(firstName, ' ', lastName) of the associated member, if only one such, or
    // (3) The concat_ws(' & ') of the two associated members with the oldest record first
    //     in the case of a partnership.
    {
        $row = $this->getAllMembershipsForSelection( NULL, "membershipId = $membershipId");
        return $row[1]['Name'];
    }

    function getAllMembershipsSql($constraint = '')
    // Returns an SQL query of membership ID numbers, membership names (for mailing), addresses and membership types for
    // all memberships. The constraint, if given, must be an 'add-able' add-on to the SQL 'where' clause, e.g. 'mailNewsletter = 1'.
    {
        $select1 = "select membershipId, membershipMailName as MembershipName, concat(address1,', ',address2,', ',city) as Address from ".
            " members, memberships, membership_types where memberships.id = membershipId ".
            " and membershipTypeId = membership_types.id and not (membershipMailName is NULL or membershipMailName = '')";
        if ($constraint != '') {
            $select1 .= " and ($constraint)";
        }

        $select2 = "select membershipId, group_concat(concat(firstName,' ', lastName) separator ' & ') as MembershipName, concat(address1,', ',address2,', ',city) as Address from ".
            " members, memberships, membership_types where memberships.id = membershipId ".
            " and membershipTypeId = membership_types.id and (membershipMailName is NULL or membershipMailName = '')" ;
        if ($constraint != '') {
            $select2 .= " and ($constraint)";
        }
        $select2 .= " group by membershipId";

        return "($select1) union ($select2) order by MembershipName";
    }

    function getAllMembershipsForSelection($leftColumnFunction, $constraint = '')
    // Return a table, suitable for use with the table->generate function, of
    // all open memberships in the club. $leftColumnFunction is a function
    // that takes the couple membership id as a parameter and returns the string to use
    // in the left column. The constraint parameter specifies an additional constraint
    // that can be used on the membership select statement 'where' clause. If non-empty
    // it is anded in.
    // This function selects all active memberships.
    //
    // Membership names are taken from the membershipMailName field if non-null (the first query below)
    // or otherwise are constructed from the associated member (or both members in the couple case).
    {
        $membershipQuery = $this->db->query($this->getAllMembershipsSql($constraint));
        $membershipRows = $membershipQuery->result_array();

        $result = array(array(''=>'', 'ID'=>'ID','Name'=>'Name','Address' => 'Address')); // Header row
        foreach ($membershipRows as $row) {
            $membershipId = $row['membershipId'];
            if (!($leftColumnFunction === NULL)) {
                $thisRow['LeftCol'] = $leftColumnFunction($membershipId);
            }
            else {
                $thisRow['LeftCol'] = '';
            }
            $thisRow['ID'] = $membershipId;
            $thisRow['Name'] = $row['MembershipName'];
            $thisRow['Address'] = $row['Address'];
            array_push($result, $thisRow);
        }
        return $result;
    }

    function getAllCouplesForDecoupling()
    // Return a selected subset of the member fields for all members who are couples.
    // Result is a table of membershipIds, names and addresses with a left column that
    // is a link back to the decoupleMembers controller function.
    {
        function coupleZapper($membershipId) {
            return anchor("ctc/decoupleMembers/$membershipId", "Zap");
        }
        $this->load->helper('url');
        return $this->getAllMembershipsForSelection('coupleZapper',
               "statusAdmin='Active' AND (membershipTypeEnum like '%Couple')");
    }

    function getMembershipTypeId($typeString)
    // Return the membership type id corresponding to the given string
    {
        $query = $this->db->get_where('membership_types', array('membershipTypeEnum'=> $typeString));
        $row = $query->row();
        return $row->id;
    }

    function getPartnerName($id)
    // Get the name of the partner for this member as a simple FirstName LastName string.
    {
        $partner = NULL;
        $select = "select firstName, lastName from members, " .
          " (select memberships.id as membID from members, memberships where membershipId = memberships.id and members.id = $id)".
          " as junk where membershipId = membID and not (members.id = $id)";
        $query = $this->db->query($select);
        if ($query->num_rows() > 0) {
            $row = $query->row_array();
            $partner = $row['firstName'] . ' ' . $row['lastName'];
        }
        return $partner;
    }

    function getMemberEmailsSql()
    // A list of primary and secondary email addresses of individual members.
    {
        $sql = "select concat(firstName, ' ', lastName) as Name, primaryEmail, secondaryEmail " .
                " from members, memberships where memberships.id = membershipId and " .
                " statusAdmin = 'Active' and not (primaryEmail is NULL or primaryEmail = '') order by Name ";
        return $sql;
    }

    function getMembershipEmailsSql()
    // A list of email addresses for each active membership, used for the club bulk emailing.
    // Uses the specific membership email address if given, else the email address of
    // the member or, where a couple share a membership and both have emails, the
    // email address of the member who has been with the club the longest.
    {
        $membershipNamesTable = $this->getAllMembershipsSql();

        $specifiedMembershipEmails = "select 0 as junk, id as membershipId, membershipEmail as email from memberships " .
                    " where not (membershipEmail is NULL or membershipEmail = '') and statusAdmin = 'Active'";

        $memberEmails = "select min(members.id) as junk, membershipId, primaryEmail as email from members, memberships " .
                    " where membershipId = memberships.id and statusAdmin = 'Active' " .
                    " and not (primaryEmail is NULL or primaryEmail = '') " .
                    " and (membershipEmail is NULL or membershipEmail = '') group by membershipId";

        $sql = "select membershipName, email " .
                " from ($specifiedMembershipEmails union $memberEmails) as Emails, ($membershipNamesTable) as Names ".
                " where Emails.membershipId = Names.membershipId";

        return $sql;
    }

    function getQueries($userId)
    // Return a query result-array of the names and descriptions of all
    // in the user_queries table for the given user.
    {
        $query = $this->db->query(
          "select id, description, name, sqlquery from user_queries where userIdAdmin='$userId' order by name");
          return $query->result_array();
    }

    function getQuery($id)
    // Return a query result row of the name and sqlQuery for the
    // query with the given id.
    {
        $query = $this->db->query("select name, description, sqlquery, userIdAdmin from user_queries where id = $id");
        return $query->row_array();
    }


    /**
     * Returns the given saved db query result (which in this case
     * is an array of db row objects).
     * @param $id the id of the saved query as returned by a call to saveQuery
     */
    function getSavedResult($id) {
        $result = NULL;
        $query = $this->db->get_where("saved_query_results", array('id'=>$id));
        if ($query->num_rows() > 0) {
            $row = $query->row();
            $result = unserialize(base64_decode($row->result));
        }
        return $result;
    }


    function getMembershipPaymentStatus($year, $id=0)
    // If id = 0 (the default) return a query suitable for use in bulk entry
    // of subs payments for a given year.
    // Memberhips that are paid for the given year still
    // appear in the list.
    // If an id is given, only the row matching that particular member id
    // (NB *not* membershipid) is returned.
    // THIS VERSION IS FOR 2008 USE ONLY (as it uses member IDs rather than
    // membership IDs, and has both logins of partners displayed).
    {
        $sql =
"SELECT
    MSID,
    IDs,
    MembershipName,
    Type, Login as Login, Fee, '' as Paid,
    amountPaid as Amount,
    cardNumber as CardNum, secondaryCardnumber as Card2Num,
    concat(right(paymentDate,2),'-',mid(paymentDate,6,2),'-',left(paymentDate,4)) as DatePaid,
    notes as Notes

FROM
   (SELECT
        membershipId as MSID,
        group_concat(cast(members.id as char(10)) separator ' / ') as IDs,
        group_concat(concat(lastName, ', ', firstName) separator ' & ') as MembershipName,
        membershipTypeEnum as Type,
        group_concat(loginName separator ' / ') as Login,
        membershipFee + if(mailNewsletterBool='Yes', newsletterFee,0) as Fee
    FROM  members, memberships, membership_types
    WHERE membershipId = memberships.id
    AND   membershipTypeId = membership_types.id
    AND   (statusAdmin = 'Active' or statusAdmin = 'Pending')
GROUP BY MSID
   )  AS mships

LEFT JOIN
   (SELECT * FROM subs_payments
    WHERE subscriptionYear = '$year'
    AND NOT deletedBoolAdmin
   ) as subs

ON   MSID = subs.membershipId

ORDER BY MembershipName";

        if ($id != 0) {
            $sql = "SELECT * FROM ($sql) AS allRows WHERE IDs = '$id' OR IDs like '$id %' OR IDs like '% $id'";
        }
        $query = $this->genericQuery($sql);
        return $query;
    }

    function getPaymentsList($year)
    // Return a query that will yield a list of all payment details for a given year.
    {
        $sql =
"SELECT
    id as ID,
    mships.*,
    amountPaid as Amount,
    cardNumber as CardNum, secondaryCardnumber as Card2Num,
    concat(right(paymentDate,2),'-',mid(paymentDate,6,2),'-',left(paymentDate,4)) as DatePaid,
    notes as Notes

FROM
   (SELECT membershipId as MSID,
                 group_concat(concat(firstName, ' ', lastName) separator ' & ') as MembershipName,
                 membershipTypeEnum as Type, loginName as Login
    FROM members, memberships, membership_types
    WHERE membershipId = memberships.id
    AND   membershipTypeId = membership_types.id
    AND   statusAdmin = 'Active'
    GROUP BY MSID
   )  AS mships

JOIN
   (SELECT * FROM subs_payments
    WHERE subscriptionYear = '$year'
    AND NOT deletedBoolAdmin
   ) AS subs

ON   MSID = subs.membershipId
AND NOT deletedBoolAdmin
ORDER BY membershipName";
        $query = $this->genericQuery($sql);
        return $query;
    }

    function getMembershipNameFromSubsPayment($paymentId)
    // Return the membership name corresponding to the given subs_payments id
    {
        $query = $this->db->get_where('subs_payments', array('id'=>$paymentId));
        $row = $query->row_array();
        $membershipId = $row['membershipId'];
        return $this->getMembershipName($membershipId);
    }


    /**
     * Returns an iterable of the documents that might be usable as targets of
     * a printMerge command -- see queries.php. This function accesses the
     * view_documents view, which is a view into the Newsletter.documents table.

     * Return value is query result of all rows from the documents table with
     * names containing the word merge and ending in $extt.
     */

    function getMergeDocuments($ext)
    {
        $docQuery = $this->db->get_where('view_documents', "name like '%merge%.$ext'");
        return $docQuery->result();
    }


    // Get the merge document with the given id
    function getDocument($id) {
        $query = $this->db->get_where('view_documents', array('id'=>$id));
        if ($query->num_rows() != 1) {
            die('Oops -- missing document. Please report this error');
        }
        return $query->row()->data;
    }

    // ROLE MANAGEMENT
    // ===============
    /**
     * A query result on the Roles table, i.e. an array of role objects
     */
    function getRoles()
    {
        return $this->db->get('roles')->result();
    }

    /**
     * The role (name) with the given ID
     * @param $roleId
     */
    function getRole($roleId)
    {
        $result = $this->db->where(array('id'=> $roleId))->get('roles')->row();
        return $result->role;
    }

    /**
     * Returns an array of (memberId, name) pairs for all active members.
     * Each array element is an object.
     */
    function getActiveMembers()
    {
        $this->db->select("members.id as id, concat(firstName, ' ', lastName) as name", FALSE);
        $this->db->from("members, memberships");
        $this->db->where("memberships.id = members.membershipId and statusAdmin='Active'");
        $this->db->order_by("name");
        return $this->db->get()->result();
    }

    /**
     * An array of pairs (memberName, role)
     */
    function getCurrentRoles()
    {
        $this->db->select("members.id as memberId, concat(firstName, ' ', lastName) as name, roles.id as roleId, role", FALSE);
        $this->db->from("members, roles, members_roles");
        $this->db->order_by("roleId");;
        $this->db->where("members.id = memberId and roles.id = roleId");
        return $this->db->get()->result();
    }

    function addRole($newMemberId, $roleId)
    {
        $this->db->insert('members_roles', array('memberId'=>$newMemberId, 'roleId'=>$roleId));
    }

    function deleteRole($memberId, $roleId)
    {
        $this->db->delete('members_roles', array('memberId'=>$memberId, 'roleId'=>$roleId));
    }


    // INTERNAL SUPPORT FUNCTIONS
    // ==========================

    function getMemberIds($membershipId)
    // Return an array of IDs of members who share this membershipId.
    // Should be either 1 or 2.
    {
        $query = $this->db->query(
          "select id from members where membershipId = $membershipId");
        $rows = $query->result_array();
        $result = array();
        foreach ($rows as $row) {
            array_push($result, $row['id']);
        }
        return $result;
    }

    function getIdFromLogin($login)
    // Return the membership ID of the user with the given login.
    // Returns -1 if no such login.
    {
        $this->db->select('id');
        $this->db->where('loginName', $login);
        $query = $this->db->get('members');
        if ($query->num_rows() != 1) {
            return -1;
        }
        else {
            return $query->row()->id;
        }
    }


    function insertMembership($membershipType, $membershipData)
    // Inserts a new entry of the given membership type in the 'memberships' table, return its id.
    // The parameter is an associative array of all the fields for which non-default
    // values are required.
    {
        global $userData;
        $query = $this->db->get_where('membership_types', array('membershipTypeEnum' => $membershipType));
        if ($query->num_rows() != 1) {
            return false;  // Bad type given
        }
        $row = $query->row();
        $membershipTypeId = $row->id;
        $membershipData['membershipTypeId'] = $membershipTypeId;
        $membershipData['userIdAdmin'] = $userData['userid'];
        $this->db->set($membershipData);
        $this->db->set('dateOpenedAdmin','now()',false);
        $this->db->insert('memberships');
        $id = $this->db->insert_id();
        return $id;
    }

    function getAllMembersForSelection($leftColumnFunction, $constraint = '')
    // Return a table, suitable for use with the table->generate function, containing
    // a selected subset of the fields of all members in the club. $leftColumnFunction
    // is a function that takes the member id as a parameter and returns the string to use
    // in the left column. The constraint parameter specifies an additional constraint
    // that can be used on the membership select statement 'where' clause. If non-empty
    // it is anded in.
    {
        $select = "select " .
          "members.id as 'ID', concat(firstName, ' ', lastName) as 'Name', membershipTypeEnum as 'Type', ".
          "concat(address1, ', ', address2, ', ', city) as 'Address'," .
          "homePhone as 'Phone' from " .
          "members, memberships, membership_types where " .
          "membershipId = memberships.id and memberships.membershipTypeId = membership_types.id ";
        if ($constraint != '') {
            $select .= " and $constraint ";
        }
        $select .=  " order by Name";
        $query = $this->db->query($select);
        $header = $query->list_fields();
        $header[0] = '';  // Replacing ID with Edit link
        $rows = $query->result_array();
        $result[0] = $header;  // Header row
        foreach ($rows as $row) { // Copy all rows across to result, inserting left column
            $id = $row['ID'];
            if (!($leftColumnFunction === NULL)) {
                $leftCol = $leftColumnFunction($id);
            }
            else {
                $leftCol = '';
            }
            $values = array_values($row);
            $values[0] = $leftCol;  // Replace ID with link
            array_push($result, $values);
        }
        return $result;
    }

    function getFieldsFromPost($fields, $includeEmpties = True, $suffix = "")
    // Returns an associative (fieldName, fieldValue) array by pulling out a value
    // from the POST array for every given field (if it exists). The $includeEmpties parameter
    // controls whether fields left empty in the form are included. By
    // default they are (so that the user can clear non-empty fields).
    // The suffix is appended to each name when looking it up in the POST so that, e.g.,
    // can pull out all the member1 then all the member2 fields from the couple's form.

    // TODO: consider whether to include XSS filtering in the call to
    // $this->input->post. Could it mess up password processing?
    // Is is already messed up?!
    {
        $map = array();
        foreach ($fields as $field) {
            if (array_key_exists($field.$suffix, $_POST)) {
                $value = $this->input->post($field.$suffix);
                if ($includeEmpties || $value != '') {
                    $map[$field] = $value;
                }
            }
        }
        return $map;
    }

    function updateTableFromPost($tableName, $id, $postFields)
    // Update the given (table, rowId) row from the given fields of the $_POST variable.
    // Returns the number of affected rows.
    {
        $map = $this->getFieldsFromPost($postFields);
        $this->db->update($tableName, $map, array('id'=>$id));
        $result = $this->db->affected_rows();
        return $result;
    }

    function filterNonModifiable($fields)
    // Returns all the fields in the parameter array that don't end in Id or Admin
    {
        $result = array();
        foreach ($fields as $field)
        {
            if (!(strtoupper(substr($field,-2))=='ID' || strtoupper(substr($field,-5)) == 'ADMIN')) {
                array_push($result, $field);
            }
        }
        return $result;
    }

    function isValidLogin($login, $memberId)
    // True iff it would be valid to set the login for the given member to the given value.
    // By setting $memberId to -1 the function can be used to check if the login would be
    // valid for a new member.
    {
        $query = $this->db->query("select firstName, lastName from members where loginName='$login' ".
                  "and not (id=$memberId)");
        return $query->num_rows() == 0;
    }

    function recordMembershipUpdate($membershipId, $fieldName, $oldValue, $newValue, $notes='' )
    {
        global $userData;
        $this->db->insert('membership_updates', array(
            'membershipId' => $membershipId,
            'fieldName' => $fieldName,
            'oldValue' => $oldValue,
            'newValue' => $newValue,
            'notes' => $notes,
            'userIdAdmin' => $userData['userid']));
    }

    function recordMemberUpdate($memberId,  $fieldName, $oldValue, $newValue, $notes='' )
    // Make an entry in the member_update table
    {
        global $userData;
        $this->db->insert('member_updates', array(
            'memberId' => $memberId,
            'fieldName' => $fieldName,
            'oldValue' => $oldValue,
            'newValue' => $newValue,
            'notes' => $notes,
            'userIdAdmin' => $userData['userid']));
    }

    function recordSubsPaymentUpdate($subsPaymentId, $fieldName, $oldValue, $newValue )
    {
        global $userData;
        $this->db->insert('subs_payments_updates', array(
            'subsPaymentsId' => $subsPaymentId,
            'fieldName' => $fieldName,
            'oldValue' => $oldValue,
            'newValue' => $newValue,
            'notes' => '',
            'userIdAdmin' => $userData['userid']));
    }

    function dateConvertFromSusan()
    // Returns the SQL function that converts Susan's format RESIGNED date to a MySQL format
    // I really hope I never have to write or touch this again, but I'm sticking it here for
    // safekeeping just in case.
    {
        return "select ResignedDate, concat(mid(ResignedDate,locate('/',ResignedDate,locate('/',ResignedDate)+1)+1,4),".
         " '/', mid(ResignedDate, locate('/',ResignedDate)+1, 1+locate('/', ResignedDate, locate('/',ResignedDate)) -".
         " locate('/',ResignedDate)), '/', left(ResignedDate,locate('/',ResignedDate)-1))";
    }


    function generatePassword($loginName) {
        return $loginName . "." . strval(rand(1000,9999));
    }

    // Hash the password following the standard Joomla approach
    function hashPassword($pass)
    {
        $saltChars  = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        $salt   = '';
        mt_srand(10000000*(double)microtime());
        for ($i = 0; $i < 16; $i++) {
            $salt .= $saltChars[mt_rand(0,61)];
        }
        $crypt = md5($pass.$salt);
        return $crypt.':'.$salt;
    }

    function sendWelcomeEmail($loginName, $pass)
    {
        global $userData;
        $id = $this->getIdFromLogin($loginName);
        $memberData = $this->getMemberDataByMemberId($id);
        $memberData['pass'] = $pass;

        $userEmail = $userData['email'];
        $to = $memberData['primaryEmail'];
        if ($to == "") {
            $to = $userEmail;
            $subject = "CTC_DB_WARNING. Couldn't send welcome email to $loginName. No primary email";
            $cc = null;
        }
        else {
            $subject = 'Welcome to the CTC';
            $cc = $userEmail;
        }
        $welcomeMessage = $this->buildWelcomeMessage($memberData);
        $this->load->helper('utilities');
        $name = $userData['name'];
        // echo "Sending email from $userEmail ($name) to $to ($loginName), subject = $subject<br />";
        sendEmail($userEmail, $name, $to, $subject, $welcomeMessage, $cc);
    }

    function buildWelcomeMessage($memberData)
    // Builds the body of the CTC welcome message
    // from the form letter 'welcome' stored in the email_messages table.
    {
        $result = $this->db->query("select message from email_messages where name='welcome'");
        $template = $result->row()->message;
        $bits = explode("$", $template);
        for ($i=1; $i < count($bits); $i += 2) {
            $bits[$i] = $memberData[$bits[$i]];
        }
        $message = implode($bits);
        return $message;
    }


    function addEmailBatch($docId, $subject, $numRecipients) {
        // Record info about a new batch of emails to be sent (maybe).
        // Not all batches will actually be sent -- user may cancel, and
        // the batch will remain until deleted by housekeeping.
        $this->db->insert('email_batch', array(
            'docId'     => $docId,
            'subject'   => $subject,
            'num_recipients' => $numRecipients)
        );
        return $this->db->insert_id();
    }



    function queueMailItem($batchId, $to, $subject, $body, $from = 'webmaster@ctc.org.nz')
    // Put an item in the queue of mail items to send as a batch
    // Returns the id of the inserted item (rarely useful).
    {
        $mailItem = array('batchId' => $batchId,
                          'to' => $to,
                          'from' => $from,
                          'subject' => $subject,
                          'body' => $body);
        $result = $this->db->insert('email_queue', $mailItem);
        return $this->db->insert_id();
    }


    function getNextMailItem($batchId)
    // Gets the first unsent email with the given batchId.
    // Returns mailItem or FALSE if none available.
    {
        $query = $this->db->get_where('email_queue', array('batchId' => $batchId), 1);
        if ($query->num_rows() > 0) {
            return $query->row();
        }
        else {
            return FALSE;
        }
    }


    function lockMailQueue()
    // Gets a write lock on the mail queue to prevent multiple sessions
    // manipulating it.
    {
        $this->db->query('LOCK TABLES email_queue WRITE, email_log WRITE, email_batch WRITE');
    }


    function unlockMailQueue()
    // Gets a write lock on the mail queue to prevent multiple sessions
    // manipulating it.
    {
        $this->db->query('UNLOCK TABLES');
    }


    function incompleteBatches()
    {
    // Query to return a list of confirmed batches
        $query = $this->db->query("select id from email_batch where state='CONFIRMED'");
        $batches = array();
        foreach( $query->result() as $row) {
            $batches[] = $row->id;
        }
        return $batches;
    }


    function confirmMailBatch($batchId)
    // Confirm that the given batch of emails is ready to send.
    {
        $this->db->where(array('id'=>$batchId));
        $this->db->update('email_batch', array('state' => 'CONFIRMED'));
    }


    function deleteMailItem($id) {
        $this->db->delete('email_queue', array('id'=>$id));
    }


    function closeBatch($batchId)
    // Mark the given batch as DONE. Send an email to webmaster
    {
        $webmaster = 'webmaster@ctc.org.nz';
        $this->db->where(array('id' => $batchId));
        $this->db->update('email_batch', array('state' => 'DONE'));
        $q = $this->db->get_where('email_batch', array('id' => $batchId));
        $row = $q->row();
        $message = "Batch email id {$row->id}, subject '{$row->subject}' ".
                "successfully sent to {$row->num_recipients} recipients.";
        sendEmail($webmaster, 'Christchurch Tramping Club', $webmaster,
                'Email Batch Sent', $message);
    }


    function purgeOldMailItems()
    {
        $this->db->query(
           "DELETE email_queue
            FROM email_queue
            INNER JOIN email_batch
            ON email_batch.id = batchId
            WHERE DATEDIFF(NOW(), email_batch.timestamp) > 5
            ");
    }


    function _phoneNumsMatch($phone1, $phone2) {
        // True iff two phone numbers match. A leading '+' is converted
        // to 00. A single leading 0 is converted to 0064. All other numbers
        // have 00643 prepended. Both numbers are then stripped of non-numerics
        // and compared.
        return $this->_normalisePhone($phone1) === $this->_normalisePhone($phone2);
    }

    function _normalisePhone($ph) {
        if (strlen($ph) < 2) return $ph; // Invalid. Ignore.

        if ($ph[0] == '+') {
            $ph = '00' . substr($ph, 1);
        }
        elseif ($ph[0] == '0' && $ph[1] == '0') {
            // Nothing to do
        }
        elseif ($ph[0] == '0') {  // NZ local area code given
            $ph = '0064' . substr($ph, 1);
        }
        else {  // No area code. Assume 03
            $ph = '00643' . $ph;
        }
        return str_replace(array('-', ' '), '', $ph);
    }

}
?>
