<?php

namespace App\Models;

use CodeIgniter\Model;

// The 'model' for the CTC DB. Theoretically, all code that is dependent
// upon the database schema resides in this module, but that rapidly became
// impracticable for the various queries and is totally dispensed with in
// the case of the User/System SQL queries. However, all actual queries should
// at least pass through this module and it is very important at least to
// ensure that all updates are done from within this module.

// This module also converts all non-admin dates to/from MySQL YYYY-MM-DD format in
// the database to NZ DD-MM-YYYY format for use by all code outside this
// module. The exception is the query module which does its own querying
// and so is responsible for any date format changes. Also, the resignationDateAdmin
// field, being nominally tagged as 'Admin' must be handled outside.


// TODO consider transaction locking for multi-record updates.
// TODO figure out what's needed to deal with timezones correctly.
class CTCModel extends Model
{
    private $memberFields;
    private $membershipFields;

    private const MaximumResultCount = 20;

    function __construct()
    {
        // Call the Model constructor
        parent::__construct();
        $this->setTable('members');

        helper('date');

        $this->memberFields = $this->db->getFieldNames('members');
        $this->membershipFields = $this->db->getFieldNames('memberships');
        $this->allowedFields = array_merge( $this->membershipFields, $this->memberFields );
    }

    // DATABASE INSERTION AND UPDATE FUNCTIONS
    // =======================================

    // Creates a new entry in the Members and Memberships tables using all the data in the current
    // $_POST form, which is assumed to contain all the fields generated by the getNewMemberData function.
    // Returns the membershipId of the new member or False if something blows up.
    // Sends a welcome-to-the-club email, unless it's a prospective.
    public function insertMember($request)
    {
        $memberData = $this->getFieldsFromRequest($request, $this->memberFields, false);
        $membershipData = $this->getFieldsFromRequest($request, $this->membershipFields, false);
        $membershipType = $request->getPost('membershipTypeEnum');
        $this->allowedFields = array_merge( $this->membershipFields, $this->memberFields );
        return $this->insertMember2($membershipType, $memberData, $membershipData);
    }

    // Phase 2 of the member insertion sequence. The various fields for the
    // new membership must be in the $memberData and $membershipData fields.
    // If the latter is null, the new member is assumed to be part of a couple
    // where the membership row has already been added. The $memberData array
    // should then have a defined $memberData['membershipId'] field.
    public function insertMember2($membershipType, $memberData, $membershipData=null)
    {
        if ($membershipData != null) {
            if ($membershipType == 'Prospective') {
                $membershipData['statusAdmin'] = 'Pending';
            }
            else {
                $membershipData['statusAdmin'] = 'Active';
            }
            $membershipId = $this->insertMembership($membershipType, $membershipData);
            if ($membershipId === false) {
                return false;
            }
            $memberData['membershipId'] = $membershipId;
        }

        assert(isset($memberData['membershipId']));

        if (isset($memberData['dateJoined'])) {
            $memberData['dateJoined'] = date_to_mysql($memberData['dateJoined']);
        }
        else {
            $memberData['dateJoined'] = date("Y-m-d");
        }
        $memberData['userIdAdmin'] = session()->userID;
        $loginName = $memberData['loginName'];
        $pass = $this->generatePassword($loginName);
        $memberData['joomlaPasswordAdmin'] = $this->hashPassword($pass);
        $this->db->table('members')->insert($memberData);
        $id = $this->db->insertID();
        if ($membershipType != 'Prospective' && $membershipType != 'PseudoMember') {
            $this->sendWelcomeEmail($id, $pass);
        }
        return $memberData['membershipId'];
    }

    // Creates two new entries in the Members table and one new Membership entry using
    // all the data in the current $_POST form.
    // TODO: Allow insertion of AssociateCouple memberships.
    public function insertCouple($request)
    {
        $membershipData = $this->getFieldsFromRequest($request, $this->membershipFields, false);
        $memberData1 = $this->getFieldsFromRequest($request, $this->memberFields, false, "__1");
        $membershipId = $this->insertMember2('Couple', $memberData1, $membershipData);
        if ($membershipId == false) {
            return false;
        }

        $memberData2 = $this->getFieldsFromRequest($request, $this->memberFields, false, "__2");
        $memberData2['membershipId'] = $membershipId;
        $success = $this->insertMember2('Couple', $memberData2);
        return $success;
    }

    public function updateJoomlaLogin($oldLogin, $newLogin){
        if (!defined('_JEXEC')) {
          define('_JEXEC', 1);
        }
        if (!defined('JPATH_BASE')) {
          define('JPATH_BASE', config('Joomla')->joomlaBase);
        }
        require_once ( JPATH_BASE . '/includes/defines.php' );
        require_once ( JPATH_BASE . '/includes/framework.php' );
        $user = JFactory::getUser($oldLogin);
        $user->username = $newLogin;
        $user->save(true);
    }


    // Writes all the data in the current $_POST form, which is assumed to be from a
    // memberUpdate or profileUpdate form, to the database (both members and memberships tables).
    // $isProfileUpdate is true if the update is from a profile update,
    // which permits only a restricted subset of fields to be updated.
    // Also records, in the member_updates and membership_updates, any columns that
    // changed.
    // Returns an associative array of all changes: key is the field name,
    // value is a 2-element array containing the old value and the new
    // value. Returns an empty array if no actual changes took place,
    // null if there was a fatal error of some sort (currently unimplemented).
    public function updateMember($id, $request, $isProfileUpdate = false)
    {
        $changes = array();
        $memberOverrides = array();
        if (isset($_POST['dateJoined'])) {
            $memberOverrides['dateJoined'] = date_to_mysql($request->getPostGet('dateJoined'));
        }
        $memberFields = $isProfileUpdate ? $this->getMemberProfileFields() : $this->getMemberFields();
        $getQuery = "select " . implode(',', $memberFields ) . " from members where id = $id";
        $query = $this->db->query($getQuery);
        $row = $query->getRowArray();
        $newLogin = "";
        $oldLogin = "";
        foreach ($memberFields as $field) {
            $newValue = $request->getPostGet($field);
            if ($newValue != $row[$field]) {
                if ($field == "loginName"){
                    $oldLogin = $row[$field];
                    $newLogin = $newValue;
                }
                $oldValue = $row[$field];
                if ($oldValue == NULL) {
                    $oldValue = 'NULL';
                }
                $this->recordMemberUpdate($id, $field, $oldValue, $newValue);
                $changes[$field] = array($oldValue, $newValue);
            }
        }
        $this->updateTableFromPost($request, 'members', $id, $memberFields, $memberOverrides);
        if ($newLogin !== "" && $oldLogin !== $newLogin) {
            $this->updateJoomlaLogin($oldLogin, $newLogin);
        }
        $membershipId = $this->getMembershipId($id);
        if ($isProfileUpdate) {
            $membershipFields = $this->getMembershipProfileFields();
        } else {
            $membershipFields = $this->getMembershipFields();
            array_push($membershipFields, 'membershipTypeEnum');
        }

        $getQuery = "select " . implode(',', $membershipFields ) .
                " from memberships, membership_types where memberships.id = $membershipId and membershipTypeId = membership_types.id";
        $query = $this->db->query($getQuery);
        $row = $query->getRowArray();
        $membershipOverrides = array();
        foreach ($membershipFields as $field) {
            $newValue = $request->getPostGet($field);
            if ($newValue != $row[$field]) {
                $oldValue = $row[$field];
                if ($oldValue == null) {
                    $oldValue = 'NULL';
                }
                if ($field == 'membershipTypeEnum' && $oldValue == 'Prospective' && $oldValue != $newValue ) {
                    // Activate membership of a prospective who changes to any other membership type
                    // TODO: Test drive this prospective membership change code
                    array_push($membershipFields, 'statusAdmin');
                    $membershipOverrides['statusAdmin'] = 'Active';
                    $loginName = $equest->getPost('loginName');
                    $pass = $this->generatePassword($loginName);
                    $this->setMemberPasswordRaw($id, $pass);
                    $this->sendWelcomeEmail($id, $pass);
                }
                $this->recordMembershipUpdate($membershipId, $field, $oldValue, $newValue);
                $changes[$field] = array($oldValue, $newValue);
                if ($field == 'membershipTypeEnum') {  // Change of membership type?
                    $newId = $this->getMembershipTypeId($newValue);
                    array_push($membershipFields, 'membershipTypeId');
                    $membershipOverrides['membershipTypeId'] = $newId;
                }
            }
        }

        $membershipFields = array_diff($membershipFields, array('membershipTypeEnum'));
        $this->updateTableFromPost($request, 'memberships', $membershipId, $membershipFields, $membershipOverrides);
        return $changes;
    }

    // Close the memberships for the two given members and open a new 'Couple' one
    // by cloning the data from $id1, replacing fields with data given
    // in $membershipFields when this is non-null. The links from members to the two
    // now defunct memberships table entries are recorded in the members_memberships table
    // and the members themselves are linked to the new memberships entry.
    // Return true if successful.
    // TODO: Allow for possibility of a coupling generating an AssociateCouple.
    public function coupleMembers($id1, $id2, $membershipFields)
    {
        // Validate the new members IDs and current status/type.

        $member1Data = $this->getMembershipDataByMemberID($id1);
        $member2Data = $this->getMembershipDataByMemberID($id2);
        if (strpos($member1Data['membershipTypeEnum'] . $member2Data['membershipTypeEnum'], 'Couple') !== false ) {
            return false;  // Neither of existing memberships can be a couple type
        }

        // Extract all the data from the first membership and the given form data
        // to build a new membership entry

        $membershipId1 = $member1Data['membershipId'];
        $membershipId2 = $member2Data['membershipId'];
        $newMembership = array();

        $dontCopy = array('membershipId', 'membershipTypeEnum','statusAdmin');
        foreach (array_keys($member1Data) as $key) {
            if (!in_array($key, $dontCopy)) {
                if ($membershipFields[$key] != '') {
                    $newMembership[$key] = $membershipFields[$key];  // Use form data if given
                } else {
                    $newMembership[$key] = $member1Data[$key];   // Else copy from member 1
                }
            }
        }

        // Close off the two existing memberships records and record the defunct
        // linkages in members_memberships

        $this->db->query("UPDATE memberships ".
                         "SET dateClosedAdmin=now(), statusAdmin = 'Coupled' ".
                         "WHERE id = $membershipId1 OR id = $membershipId2");
        if ($this->db->affectedRows() != 2) {
            return false;
        }
        $this->db->table('members_memberships')->insert(array('memberId'=>$id1, 'membershipId'=>$membershipId1));
        $this->db->table('members_memberships')->insert(array('memberId'=>$id2, 'membershipId'=>$membershipId2));

        // Insert the new memberships row and link the two members to it

        $newMembershipId = $this->insertMembership('Couple', $newMembership);
        $this->db->table('members')->update(array('membershipId'=>$newMembershipId), "id = $id1 or id = $id2");
        if ($this->db->affectedRows() != 2) {
            return false;
        }

        return true;  // Optimism!
    }

    // Decouple the given couple membership into two new separate
    // membership, each a copy of the couple membership (but with the
    // membership name, membership email and all administrative fields cleared).
    public function decouple($membershipId)
    {
        $query = $this->db->table('memberships')->getWhere(array('id'=>$membershipId));
        $row = $query->getRowArray();
        $ids = $this->getMemberIDs($membershipId);
        if ($ids == NULL || count($ids) != 2) {
            return false;
        }
        $id1 = $ids[0];
        $id2 = $ids[1];
        $this->db->query(
            "update memberships set dateClosedAdmin=now(), statusAdmin='Decoupled' where id = $membershipId");
        if ($this->db->affectedRows() != 1) {
            return false;
        }
        // Record the two defunct linkages
        $this->db->table('members_memberships')->insert(array('memberID' => $id1, 'membershipId' => $membershipId));
        $this->db->table('members_memberships')->insert(array('memberID' => $id2, 'membershipId' => $membershipId));

        // Build a new membership record to use for each of the new members

        // Fields we don't wish to copy to new members
        $suppressFields = array('membershipMailName', 'membershipEmail');
        $membershipFields = $this->getMembershipFields();
        foreach ($membershipFields as $field) {
            // Copy fields across unless suppressed
            if (!in_array($field, $suppressFields)) {
                $newMembership[$field] = $row[$field];
            }
        }

        // Insert the new membership twice and link the members to it.

        $newMembershipId1 = $this->insertMembership('Ordinary', $newMembership);
        $newMembershipId2 = $this->insertMembership('Ordinary', $newMembership);
        $this->db->table('members')->update(array('membershipId' => $newMembershipId1), "id = $id1");
        if ($this->db->affectedRows() != 1) {
            return false;
        }
        $this->db->table('members')->update(array('membershipId' => $newMembershipId2), "id = $id2");
        if ($this->db->affectedRows() != 1) {
            return false;
        }
        return true;
    }

    // Close the given membership record. The reason must be one of the enum values
    // for closing a membership.
    // The resignationDate parameter should be in
    // NZ format. The $notes field is the original membership notes field but perhaps
    // with additional info added on the reason for the closure. See ctc->closeMembership().
    public function closeMembership($membershipId, $reason, $resignationDate, $notes)
    {
        $resignationDateMysql = date_to_mysql($resignationDate);
        $status = $this->getMembershipStatusByMembershipId($membershipId);
        assert($status == 'Active');
        $builder = $this->db->table('memberships');
        $builder->where('id', $membershipId);
        $builder->update( [ 'statusAdmin' => $reason,
                            'dateClosedAdmin' => date('Y-m-d H:i:s'),
                            'resignationDateAdmin' => $resignationDateMysql,
                            'membershipNotes' => $notes ] );
        $ok = $this->db->affectedRows() == 1;
        $this->recordMembershipUpdate($membershipId, 'statusAdmin', $status, $reason);
        return $ok;
    }

    public function reinstateMembership($membershipId)
    {
        $status = $this->getMembershipStatusByMembershipId($membershipId);
        $this->db->query(
            "update memberships set statusAdmin='Active', dateClosedAdmin=NULL where id = $membershipId");
        $ok = $this->db->affectedRows() == 1;
        $this->recordMembershipUpdate($membershipId, 'statusAdmin', $status, 'Active', 'Reinstated');
        return $ok;
    }

    public function rejoinMember($memberID)
    // Construct a new membership for the given member (assumed to have a closed membership).
    // Copy the address from the old membership, which becomes defunct and is linked
    // to the member only via a new members-memberships table entry.
    {
        $data = $this->getMemberDataByMemberID($memberID);
        // Record the defunct membership
        $this->db->table('members_memberships')->insert(array('memberID' => $memberID, 'membershipId' => $data['membershipId']));
        $data = array(
            'address1' => $data['address1'],
            'address2' => $data['address2'],
            'city' => $data['city'],
            'postcode' => $data['postcode']);
        $membershipId = $this->insertMembership('Ordinary', $data);
        $this->db->table('members')->update(['membershipId'=>$membershipId], "id = $memberID");
        $ok = $this->db->affectedRows() == 1;
        return $ok;
    }

    // True iff it would be valid to set the login for the given member to the given value.
    // By setting $memberID to -1 the function can be used to check if the login would be
    // valid for a new member.
    public function isValidLogin($login, $memberID)
    {
        if (!preg_match("/^([-a-z0-9_.])+$/i", $login)) {
            return "Illegal login name ($login): can contain only alphanumeric characters plus '.', '-' and '_'";
        }

        $query = $this->db->query("select firstName, lastName from members where loginName='$login' ".
                                  "and not (id=$memberID)");
        if ($query->getNumRows() !== 0) {
            return "Invalid login ($login): already in use by another member";
        }
        return true;
    }

    // Set the hashed password for the given member to the new value
    public function setMemberPassword($memberID, $newHash)
    {
        $this->db->query("update members set joomlaPasswordAdmin='$newHash' where id = $memberID");
    }

    // Return a table, suitable for use with the table->generate function, containing
    // a selected subset of the fields of all members in the club. $leftColumnFunction
    // is a function that takes the member id as a parameter and returns the string to use
    // in the left column. The constraint parameter specifies an additional constraint
    // that can be used on the membership select statement 'where' clause. If non-empty
    // it is anded in.
    public function getAllMembersForSelection($leftColumnFunction, $constraint = '')
    {
        $select = "select " .
          "members.id as 'ID', concat(firstName, ' ', lastName) as 'Name', membershipTypeEnum as 'Type', ".
          "concat(address1, ', ', address2, ', ', city) as 'Address'," .
          "homePhone as 'Phone' from " .
          "members, memberships, membership_types where " .
          "membershipId = memberships.id and memberships.membershipTypeId = membership_types.id ";
        if ($constraint != '') {
            $select .= " and $constraint ";
        }
        $select .=  " order by Name";
        $query = $this->db->query($select);
        $header = $query->getFieldNames();
        $header[0] = '';  // Replacing ID with Edit link
        $rows = $query->getResultArray();
        $result[0] = $header;  // Header row
        foreach ($rows as $row) { // Copy all rows across to result, inserting left column
            $id = $row['ID'];
            if (!($leftColumnFunction === NULL)) {
                $leftCol = $leftColumnFunction($id);
            }
            else {
                $leftCol = '';
            }
            $values = array_values($row);
            $values[0] = $leftCol;  // Replace ID with link
            array_push($result, $values);
        }
        return $result;
    }

    // Add a row to the subs_payments table for the given membership and year, or change
    // the details if such a payment already exists.
    public function addOrAlterPayment($membershipId, $data, $year)
    {
        $where = array('membershipID' => $membershipId, 'subscriptionYear'=>$year,'deletedBoolAdmin'=>0);
        if (isset($data['paymentDate'])) {
            $data['paymentDate'] = date_to_mysql($data['paymentDate']);
        }
        $query = $this->db->table('subs_payments')->getWhere($where);
        if ($query->getNumRows() == 0) {  // New payment?
            $data['userIdAdmin'] = session()->userID;
            $this->db->table('subs_payments')->insert(array_merge($where, $data));
        }
        else {  // Case where a payment is being altered
            // Firstly find all altered fields and record them in subs_payments_updates
            $row = $query->getRowArray();
            $subsPaymentsId = $row['id'];
            $subsFields = $this->filterNonModifiable($this->db->getFieldNames('subs_payments'));
            foreach ($subsFields as $field) {
                if (isset($data[$field]) && $data[$field] != $row[$field]) {
                    $oldValue = $row[$field];
                    if ($oldValue == NULL) $oldValue = 'null';
                    $this->recordSubsPaymentUpdate($subsPaymentsId, $field, $oldValue, $data[$field]);
                }
            }
            // Lastly, do the actual update.
            $this->db->table('subs_payments')
                     ->where($where)
                     ->update($data);
        }

        return $this->db->affectedRows();
    }

    // Delete the payment with the given id.
    public function deletePayment($paymentId)
    {
        $this->recordSubsPaymentUpdate($paymentId, 'deletedBoolAdmin', 0, 1);
        $this->db->table('subs_payments')
                 ->where(array('id'=>$paymentId))
                 ->update(array('deletedBoolAdmin'=>1));
        return $this->db->affectedRows();
    }

    // EXTERNAL SCHEMA QUERY FUNCTIONS
    // ===============================

    // A list of all dbadmin-modifiable member fields
    public function getMemberFields()
    {
        return $this->filterNonModifiable($this->db->getFieldNames('members'));
    }

    // A list of all dbadmin-modifiable membership fields
    public function getMembershipFields()
    {
        return $this->filterNonModifiable($this->db->getFieldNames('memberships'));
    }

    // A list of all member fields that can be modified by the members themselves
   public function getMemberProfileFields()
    {
        return array('firstName', 'lastName',
            'primaryEmail', 'workPhone', 'mobilePhone',
            'preferredPhoneEnum',
            'emergencyContactName', 'emergencyContactPhone',
            'onEmailListBool', 'htmlEmailBool',
            'onTripLeaderEmailListBool');
    }


    // A list of all membership fields that can be modified by the members themselves
    public function getMembershipProfileFields()
    {
        return array('homePhone', 'address1', 'address2','city','postcode');
    }

    public function getTableFields($table)
    // A list of all fields of the given table
    {
        return $this->db->getFieldNames($table);
    }

    /* Return a list of the user-modifiable data fields from the member and membership tables combined.
     * We use the convention that everything except keys (identifiers id), foreign keys (identifiers
     * ending in id) and administrative fields (identifiers ending in Admin) are user-modifiable.
     */
    public function getModifiableDataFields()
    {
        return array_merge($this->getMemberFields(), $this->getMembershipFields());
    }

    /* Return a list of all membership types */
    public function getMembershipTypes()
    {
        $query = $this->db->table('membership_types')->select('membershipTypeEnum')->get();
        $types = array();
        foreach ($query->getResult() as $row) {
            array_push($types, $row->membershipTypeEnum);
        }
        return $types;
    }

    // EXTERNAL DB QUERY FUNCTIONS
    // ===========================

    // Replace the query having the given $id with the new name and value,
    // or insert a new query if $id == 0.
    // Returns true iff update affected exactly one row.
    public function saveQuery($id, $name, $description, $query, $userId)
    {
        $query = addslashes($query);
        $description = addslashes($description);
        if ($id == 0) {
            $this->db->query("insert into user_queries
             (name, description, sqlquery, userIdAdmin) values
             ('$name', '$description', '$query', '$userId')");
        }
        else {
            $this->db->query("update user_queries set name='$name',
                description='$description', sqlquery='$query',
                userIdAdmin='$userId' where id=$id");
        }
        return $this->db->affectedRows() == 1;
    }

    public function deleteQuery($id)
    {
        $this->db->query("delete from user_queries where id = $id");
    }

    public function deleteSavedResult($id)
    {
        $this->db->table('saved_query_results')->delete(['id'=> $id]);
    }

    // Record in the saved_query_results table the result of a particular query.
    // Returns the ID of this particular query. The saved_query_results table is configured
    // to hold only a certain number of recent queries (currently 20) so an attempt
    // to retrieve the query result in the future is not totally guaranteed to succeed.

    // Why do I have to use base64_encode/decode in this? I'm not sure but it doesn't
    // work if I don't. There's lots of discussion on php.net/unserialize but most people
    // there seem as confused as me or more so.
    public function saveResult($query) {
        $result = array();
        foreach ($query->getResult() as $row) {
            $result[] = $row;
        }
        $data = base64_encode(serialize($result));
        $this->db->table("saved_query_results")->insert(['result' => $data]);
        $id = $this->db->insertID();
        $max = self::MaximumResultCount;
        $rem = $id % $max;
        $this->db->query("DELETE from saved_query_results WHERE (mod(id,$max) = $rem) and (id <> $id)");
        return $id;
    }

    /* Returns, for member with given id, all the data fields of both the Members and Memberships tables
     * that can be modified during an EditUser action, plus the membershipId, statusAdmin and membershipType
     */
    public function getMemberDataByMemberID($id)
    {
        $builder = $this->db->table(['members', 'memberships', 'membership_types']);
        $builder->select(implode(',',$this->getModifiableDataFields()) . ',membershipId, statusAdmin, membershipTypeEnum');
        $builder->where("members.id = $id and membershipId = memberships.id and membershipTypeId = membership_types.id");
        $query = $builder->get();
        $data = $query->getRowArray();
        $data['dateJoined'] = date_to_nz($data['dateJoined']);
        return $data;
    }

    /* Returns, for member with given id, all the data fields of the Memberships tables
     * that can be modified during an EditUser action, plus the membershipId, statusAdmin and membershipTypeEnum
     */
    public function getMembershipDataByMemberID($id)
    {
        $builder = $this->db->table(['members', 'memberships', 'membership_types']);
        $builder->select(implode(',',$this->getMembershipFields()) . ',membershipId, statusAdmin, membershipTypeEnum');
        $builder->where("members.id = $id and membershipId = memberships.id and membershipTypeId = membership_types.id");
        $query = $builder->get();
        return $query->getRowArray();
    }

    // Same as getMembershipDataByMemberID but given membershipId not memberID
    public function getMembershipDataByMembershipId($msid)
    {
        $builder = $this->db->table(['members', 'memberships', 'membership_types']);
        $builder->select(implode(',',$this->getMembershipFields()) . ',membershipId, statusAdmin, membershipTypeEnum');
        $builder->where("memberships.id = $msid and membershipTypeId = membership_types.id");
        $query = $builder->get();
        return $query->getRowArray();
    }

    // The status of a given membership
    public function getMembershipStatusByMembershipId($membershipId)
    {
        $query = $this->db->query("select statusAdmin from memberships where id=$membershipId");
        $result = $query->getRow();
        return $result->statusAdmin;
    }

    // Run any arbitrary query and return the DB result object.
    public function genericQuery($sql) {
        $this->db->query("set time_zone='+12:00'");
        // TODO do this properly! Check what else is affected and include Daylight Savings
        return $this->db->query($sql);
    }

    // Return a selected subset of the member fields for all members.
    // Returns the raw query result, for use in a "table->generate" command.
    public function getAllMembersForViewEdit()
    {
        helper('url');
        $makeEditLink = function($id)
        {
            return anchor("ctc/editParticularMember/$id","Edit");
        };
        return $this->getAllMembersForSelection($makeEditLink,"(statusAdmin='Active' or statusAdmin='Pending')");
    }

    // Return a selected subset of the member fields for all members.
    // Returns the raw query result, for use in a "table->generate" command.
    public function getAllMembersForPasswordSetting()
    {
        helper('url');
        $makePassLink = function($id)
        {
            return anchor("ctc/setParticularMemberPassword/$id","SetPass");
        };
        return $this->getAllMembersForSelection($makePassLink,"(statusAdmin='Active' or statusAdmin='Pending')");
    }

    // Return a selected subset of the member fields for all members.
    // Returns the raw query result, for use in a "table->generate" command.
    public function getAllMembersForCoupling()
    {
        $makeCheckBox = function($id)
        {
            return "<input type='checkbox' name='cb$id' />";
        };
        return $this->getAllMembersForSelection($makeCheckBox,
            "statusAdmin='Active' AND NOT (membershipTypeEnum like '%Couple')");
    }

    // An sql query (i.e., the text of the query) for all columns for all members with an additional constraint if desired.
    // If given the constraint must begin "and ...."
    public function getAllMembersSql($constraint = "")
    {
        $sql = "select " . implode(',', $this->getModifiableDataFields()) .
            ",statusAdmin as 'status', members.id as memberID, memberships.id as membershipId" .
            " from members, memberships, membership_types" .
            " where membershipId = memberships.id and memberships.membershipTypeId = membership_types.id  $constraint order by LastName,FirstName";
        return $sql;
    }

    public function getAllActiveMembersSql()
    {
        return $this->getAllMembersSql("and statusAdmin='Active'");
    }

    public function getAllActiveMembersByFirstNameSql()
    {
        $sql = "select " . implode(',', $this->getModifiableDataFields()) .
            ",statusAdmin as 'status', members.id as memberID, memberships.id as membershipId" .
            " from members, memberships, membership_types" .
            " where membershipId = memberships.id and memberships.membershipTypeId = membership_types.id and statusAdmin='Active' order by FirstName,LastName";
        return $sql;
    }

    public function getAllActiveMembersByFirstName()
    {
        $query = $this->db->query($this->getAllActiveMembersByFirstNameSql());
        return $query->getResult();
    }

    // An array of all active members, each element being an object.
    // UNTESTED.
    public function getAllActiveMembers() {
        $query = $this->db->query($this->getAllActiveMembersSql());
        return $query->getResult();
    }

    // Get the name in firstName lastName form for a given member
    public function getMemberName($memberID)
    {
        $query = $this->db->query("select concat(firstName,' ', lastName) as Name from members where id = $memberID");
        $row = $query->getRow();
        return $row->Name;
    }

    // Get the login name for the given member
    public function getMemberLoginName($memberID)
    {
        $query = $this->db->query("select loginName from members where id = $memberID");
        $row = $query->getRow();
        return $row->loginName;
    }


    public function getMemberLoginNameFromEmailPhoneLoginName($search_data)
    {
        $result = array('id'=>0, 'loginName'=>'', 'emailAddress'=>'', 'errorMessage'=>'');
        $select = 'select members.id, mobilePhone, workPhone, homePhone, primaryEmail, loginName from members '.
                  'join memberships on members.membershipId = memberships.id';
        $query = $this->db->query($select);
        foreach ($query->getResult() as $row) {
            if ($this->phoneNumsMatch($search_data, $row->mobilePhone)) {
               if ($result['loginName'] != "") {
                   // Ambiguous - skip mobile number checking
                   $result['errorMessage'] = "Phone number ambiguous.";
                   break;
               } else {
                   $result['loginName'] = $row->loginName;
                   $result['emailAddress'] = $row->primaryEmail;
                   $result['id'] = $row->id;
               }
            }
        }
        if ($result['loginName'] === "") {
            foreach ($query->getResult() as $row) {
                if ($this->phoneNumsMatch($search_data, $row->workPhone)) {
                    if ($result['loginName'] != "") {
                        // Ambiguous - skip mobile number checking
                        $result['errorMessage'] = "Phone number ambiguous.";
                        break;
                    } else {
                        $result['loginName'] = $row->loginName;
                        $result['emailAddress'] = $row->primaryEmail;
                        $result['id'] = $row->id;
                    }
                }
            }
        }
        if ($result['loginName'] === "") {
            foreach ($query->getResult() as $row) {
                if ($this->phoneNumsMatch($search_data, $row->homePhone)) {
                    if ($result['loginName'] != "") {
                        // Ambiguous - skip home number checking
                        $result['errorMessage'] = "Phone number ambiguous.";
                        break;
                    } else {
                        $result['loginName'] = $row->loginName;
                        $result['emailAddress'] = $row->primaryEmail;
                        $result['id'] = $row->id;
                    }
                }
            }
        }
        if ($result['loginName'] === "") {
            foreach ($query->getResult() as $row) {
                if (strtolower($search_data) === strtolower($row->primaryEmail)) {
                    if ($result['loginName'] != "") {
                        // Ambiguous - skip home number checking
                        $result['errorMessage'] = "Email address ambiguous.";
                        break;
                    } else {
                        $result['loginName'] = $row->loginName;
                        $result['emailAddress'] = $row->primaryEmail;
                        $result['id'] = $row->id;
                    }
                }
            }
        }
        if ($result['loginName'] === "") {
            foreach ($query->getResult() as $row) {
                if (strtolower($search_data) === strtolower($row->loginName)) {
                    if ($result['loginName'] != "") {
                        // Ambiguous - skip home number checking
                        $result['errorMessage'] = "Login name ambiguous. This should never happen - notify IT team please.";
                        break;
                    } else {
                        $result['loginName'] = $row->loginName;
                        $result['emailAddress'] = $row->primaryEmail;
                        $result['id'] = $row->id;
                    }
                }
            }
        }
        return $result;
    }

    // Get the id of the member with the given login.
    // Returns 0 if no such login
    public function getMemberIDFromLogin($login)
    {
        $query = $this->db->query("select id from members where loginName = $login");
        $row = $query->getRow();
        return $row->id;
    }


    // Gets the id of the member whose mobile matches the given one.
    // Returns zero if mobile can't be found.
    public function getMemberIDFromMobileNum($mob)
    {
        $query = $this->db->query('select id, mobilePhone from members');
        foreach ($query->getResult() as $row) {
            if ($this->phoneNumsMatch($mob, $row->mobilePhone)) {
                return $row->id;
            }
        }
        return 0;
    }

    // Get the hashed password for the given member
    public function getMemberPassword($memberID)
    {
        $query = $this->db->query("select joomlaPasswordAdmin as password from members where id = $memberID");
        $row = $query->getRow();
        if (!isset($row))
        {
            return null;
        }
        return $row->password;
    }

    // Hash the given password and store it
    public function setMemberPasswordRaw($memberID, $plainTextPassword)
    {
        $this->setMemberPassword($memberID, $this->hashPassword($plainTextPassword));
    }

    // Returns true iff the passed plain-text password
    // is correct for the given member
    public function isCorrectPasswordForMember($plainTextPassword, $memberID)
    {
        $currentPassword= $this->getMemberPassword($memberID);
        $bits = preg_split('/:/', $currentPassword);
        $hash = $bits[0];
        $salt = count($bits) == 2 ? $bits[1] : '';
        $ok = md5($plainTextPassword.$salt) == $hash;
        return $ok;
    }

    public function generatePassword($loginName)
    {
        return $loginName . "." . strval(rand(1000,9999));
    }

    public function getMembershipId($memberID)
    {
        $query = $this->db->query(
            "select membershipId from members where id = $memberID");
        $row = $query->getRow();
        return $row->membershipId;
    }

    // Get the most-recent membership status for a given member
    public function getMemberStatus($memberID)
    {
        $query = $this->db->query(
            "select statusAdmin from members, memberships where members.id = $memberID and membershipId = memberships.id");
        $row = $query->getRow();
        return $row->statusAdmin;
    }

    // Return an associative array of memberID=>loginName for all members who either
    // own SQL queries already or are club officers (in the sense that they
    // appear in Joomla's contacts table).
    // This is intended solely for use in displaying a list of query owners to
    // the webmaster when editing queries. See queries.php and showQueries.php.
    public function getQueryOwningMembers()
    {
        $query = $this->db->query("
            SELECT DISTINCT loginName as user, members.id as id
                 FROM user_queries JOIN members
                  ON members.id = user_queries.userIdAdmin
            UNION
            SELECT loginName as user, members.id as id
                 FROM members
                 JOIN members_roles ON members.id = members_roles.memberID
                 JOIN roles ON roleID = roles.id
                 WHERE isCommittee
            ORDER BY user");
        $result = array();
        foreach ($query->getResult() as $row) {
            $result[$row->id] = $row->user;
        }
        return $result;
    }

    // Gets the name to use for mailing to a given membership. This is:
    // (1) The membershipMailName field from the memberships table, if non-NULL, or
    // (2) The concat(firstName, ' ', lastName) of the associated member, if only one such, or
    // (3) The concat_ws(' & ') of the two associated members with the oldest record first
    //     in the case of a partnership.
    public function getMembershipName($membershipId)
    {
        $row = $this->getAllMembershipsForSelection(null, "membershipId = $membershipId");
        return $row[1]['Name'];
    }

    // Returns an SQL query of membership ID numbers, membership names (for mailing), addresses and membership types for
    // all memberships. The constraint, if given, must be an 'add-able' add-on to the SQL 'where' clause, e.g. 'mailNewsletter = 1'.
    public function getAllMembershipsSql($constraint = '')
    {
        $select1 = "select membershipId, membershipMailName as MembershipName, concat(address1,', ',address2,', ',city) as Address from ".
            " members, memberships, membership_types where memberships.id = membershipId ".
            " and membershipTypeId = membership_types.id and not (membershipMailName is NULL or membershipMailName = '')";
        if ($constraint != '') {
            $select1 .= " and ($constraint)";
        }

        $select2 = "select membershipId, group_concat(concat(firstName,' ', lastName) separator ' & ') as MembershipName, concat(address1,', ',address2,', ',city) as Address from ".
            " members, memberships, membership_types where memberships.id = membershipId ".
            " and membershipTypeId = membership_types.id and (membershipMailName is NULL or membershipMailName = '')" ;
        if ($constraint != '') {
            $select2 .= " and ($constraint)";
        }
        $select2 .= " group by membershipId";

        return "($select1) union ($select2) order by MembershipName";
    }

    // Return a table, suitable for use with the table->generate function, of
    // all open memberships in the club. $leftColumnFunction is a function
    // that takes the couple membership id as a parameter and returns the string to use
    // in the left column. The constraint parameter specifies an additional constraint
    // that can be used on the membership select statement 'where' clause. If non-empty
    // it is anded in.
    // This function selects all active memberships.
    //
    // Membership names are taken from the membershipMailName field if non-null (the first query below)
    // or otherwise are constructed from the associated member (or both members in the couple case).
    public function getAllMembershipsForSelection($leftColumnFunction, $constraint = '')
    {
        $membershipQuery = $this->db->query($this->getAllMembershipsSql($constraint));
        $membershipRows = $membershipQuery->getResultArray();

        $result = array(array(''=>'', 'ID'=>'ID','Name'=>'Name','Address' => 'Address')); // Header row
        foreach ($membershipRows as $row) {
            $membershipId = $row['membershipId'];
            if (!($leftColumnFunction === NULL)) {
                $thisRow['LeftCol'] = $leftColumnFunction($membershipId);
            } else {
                $thisRow['LeftCol'] = '';
            }
            $thisRow['ID'] = $membershipId;
            $thisRow['Name'] = $row['MembershipName'];
            $thisRow['Address'] = $row['Address'];
            array_push($result, $thisRow);
        }
        return $result;
    }

    // Return a selected subset of the member fields for all members who are couples.
    // Result is a table of membershipIds, names and addresses with a left column that
    // is a link back to the decoupleMembers controller function.
    public function getAllCouplesForDecoupling()
    {
        $coupleZapper = function ($membershipId)
        {
            return anchor("ctc/decoupleMembers/$membershipId", "Zap");
        };
        helper('url');
        return $this->getAllMembershipsForSelection($coupleZapper,
               "statusAdmin='Active' AND (membershipTypeEnum like '%Couple')");
    }

    // Return the membership type id corresponding to the given string
    public function getMembershipTypeId($typeString)
    {
        $query = $this->db->table('membership_types')->getWhere(['membershipTypeEnum'=> $typeString]);
        $row = $query->getRow();
        return $row->id;
    }

    // Get the name of the partner for this member as a simple FirstName LastName string.
    public function getPartnerName($id)
    {
        $partner = NULL;
        $select = "select firstName, lastName from members, " .
          " (select memberships.id as membID from members, memberships where membershipId = memberships.id and members.id = $id)".
          " as junk where membershipId = membID and not (members.id = $id)";
        $query = $this->db->query($select);
        if ($query->getNumRows() > 0) {
            $row = $query->getRowArray();
            $partner = $row['firstName'] . ' ' . $row['lastName'];
        }
        return $partner;
    }

    // A list of primary and secondary email addresses of individual members.
    public function getMemberEmailsSql()
    {
        $sql = "select concat(firstName, ' ', lastName) as Name, primaryEmail, secondaryEmail " .
                " from members, memberships where memberships.id = membershipId and " .
                " statusAdmin = 'Active' and not (primaryEmail is NULL or primaryEmail = '') order by Name ";
        return $sql;
    }

    // A list of email addresses for each active membership, used for the club bulk emailing.
    // Uses the specific membership email address if given, else the email address of
    // the member or, where a couple share a membership and both have emails, the
    // email address of the member who has been with the club the longest.
    public function getMembershipEmailsSql()
    {
        $membershipNamesTable = $this->getAllMembershipsSql();

        $specifiedMembershipEmails = "select 0 as junk, id as membershipId, membershipEmail as email from memberships " .
                    " where not (membershipEmail is NULL or membershipEmail = '') and statusAdmin = 'Active'";

        $memberEmails = "select min(members.id) as junk, membershipId, primaryEmail as email from members, memberships " .
                    " where membershipId = memberships.id and statusAdmin = 'Active' " .
                    " and not (primaryEmail is NULL or primaryEmail = '') " .
                    " and (membershipEmail is NULL or membershipEmail = '') group by membershipId";

        $sql = "select membershipName, email " .
                " from ($specifiedMembershipEmails union $memberEmails) as Emails, ($membershipNamesTable) as Names ".
                " where Emails.membershipId = Names.membershipId";

        return $sql;
    }

    // Return a query result-array of the names and descriptions of all
    // in the user_queries table for the given user.
    public function getQueries($userId)
    {
        $query = $this->db->query(
          "select id, description, name, sqlquery from user_queries where userIdAdmin='$userId' order by name");
          return $query->getResultArray();
    }

    // Return a query result row of the name and sqlQuery for the
    // query with the given id.
    public function getQuery($id)
    {
        $query = $this->db->query("select name, description, sqlquery, userIdAdmin from user_queries where id = $id");
        return $query->getRow();
    }


    // Returns the given saved db query result (which in this case
    // is an array of db row objects).
    // @param $id the id of the saved query as returned by a call to saveResult
    //
    public function getSavedResult($id)
    {
        $result = null;
        $query = $this->db->table("saved_query_results")->getWhere(['id'=>$id]);
        if ($query->getNumRows() > 0) {
            $row = $query->getRow();
            $result = unserialize(base64_decode($row->result));
        }
        return $result;
    }


    // If id = 0 (the default) return a query suitable for use in bulk entry
    // of subs payments for a given year.
    // Memberhips that are paid for the given year still
    // appear in the list.
    // If an id is given, only the row matching that particular member id
    // (NB *not* membershipid) is returned.
    // THIS VERSION IS FOR 2008 USE ONLY (as it uses member IDs rather than
    // membership IDs, and has both logins of partners displayed).
    public function getMembershipPaymentStatus($year, $id=0)
    {
        $sql =
            "SELECT
                MSID,
                IDs,
                MembershipName,
                Type, Login as Login, Fee, '' as Paid,
                amountPaid as Amount,
                cardNumber as CardNum, secondaryCardnumber as Card2Num,
                concat(right(paymentDate,2),'-',mid(paymentDate,6,2),'-',left(paymentDate,4)) as DatePaid,
                notes as Notes

            FROM
            (SELECT
                    membershipId as MSID,
                    group_concat(cast(members.id as char(10)) separator ' / ') as IDs,
                    group_concat(concat(lastName, ', ', firstName) separator ' & ') as MembershipName,
                    membershipTypeEnum as Type,
                    group_concat(loginName separator ' / ') as Login,
                    membershipFee + if(mailNewsletterBool='Yes', newsletterFee,0) as Fee
                FROM  members, memberships, membership_types
                WHERE membershipId = memberships.id
                AND   membershipTypeId = membership_types.id
                AND   (statusAdmin = 'Active' or statusAdmin = 'Pending')
            GROUP BY MSID
            )  AS mships

            LEFT JOIN
            (SELECT * FROM subs_payments
                WHERE subscriptionYear = '$year'
                AND NOT deletedBoolAdmin
            ) as subs

            ON   MSID = subs.membershipId

            ORDER BY MembershipName";

        if ($id != 0) {
            $sql = "SELECT * FROM ($sql) AS allRows WHERE IDs = '$id' OR IDs like '$id %' OR IDs like '% $id'";
        }
        $query = $this->genericQuery($sql);
        return $query;
    }

    // Return a query that will yield a list of all payment details for a given year.
    public function getPaymentsList($year)
    {
        $sql =
"SELECT
    id as ID,
    mships.*,
    amountPaid as Amount,
    cardNumber as CardNum, secondaryCardnumber as Card2Num,
    concat(right(paymentDate,2),'-',mid(paymentDate,6,2),'-',left(paymentDate,4)) as DatePaid,
    notes as Notes

FROM
   (SELECT membershipId as MSID,
                 group_concat(concat(firstName, ' ', lastName) separator ' & ') as MembershipName,
                 membershipTypeEnum as Type, loginName as Login
    FROM members, memberships, membership_types
    WHERE membershipId = memberships.id
    AND   membershipTypeId = membership_types.id
    AND   statusAdmin = 'Active'
    GROUP BY MSID
   )  AS mships

JOIN
   (SELECT * FROM subs_payments
    WHERE subscriptionYear = '$year'
    AND NOT deletedBoolAdmin
   ) AS subs

ON   MSID = subs.membershipId
AND NOT deletedBoolAdmin
ORDER BY membershipName";
        $query = $this->genericQuery($sql);
        return $query;
    }

    // Return the membership name corresponding to the given subs_payments id
    public function getMembershipNameFromSubsPayment($paymentId)
    {
        $query = $this->db->table('subs_payments')->getWhere(['id'=>$paymentId]);
        $row = $query->getRow();
        $membershipId = $row->membershipId;
        return $this->getMembershipName($membershipId);
    }


    /**
     * Returns an iterable of the documents that might be usable as targets of
     * a printMerge command -- see queries.php. This function accesses the
     * documents table.

     * Return value is query result of all rows from the documents table with
     * names containing the word merge and ending in $extt.
     */
    public function getMergeDocuments($ext)
    {
        $docQuery = $this->db->table('documents')->getWhere("name like '%merge%.$ext'");
        return $docQuery->getResult();
    }


    // Get the merge document with the given id
    public function getDocument($id) {
        $query = $this->db->table('documents')->getWhere(['id'=>$id]);
        if ($query->getNumRows() != 1) {
            die('Oops -- missing document. Please report this error');
        }
        return $query->getRow()->data;
    }

    // ROLE MANAGEMENT
    // ===============
    /**
     * A query result on the Roles table, i.e. an array of role objects
     */
    public function getRoles()
    {
        return $this->db->table('roles')->get()->getResult();
    }

    /**
     * The role (name) with the given ID
     * @param $roleID
     */
    public function getRole($roleID)
    {
        $result = $this->db->table('roles')->getWhere(['id'=> $roleID])->getRow();
        return $result->role;
    }

    /**
     * Returns an array of (memberID, name) objects for all active members.
     * Each array element is an object.
     */
    public function getActiveMembers()
    {
        $query = $this->db->table(['members', 'memberships'])
            ->select("members.id as id, concat(firstName, ' ', lastName) as name", false)
            ->where("memberships.id = members.membershipId and statusAdmin='Active'")
            ->orderBy("name")
            ->get();
        return $query->getResult();
    }

    /**
     * An array of objects (memberName, role)
     */
    public function getCurrentRoles()
    {
        $query = $this->db->table(['members', 'roles', 'members_roles'])
             ->select("members.id as memberID, concat(firstName, ' ', lastName) as name, roles.id as roleID, role", false)
             ->orderBy("roleID")
             ->where("members.id = memberID and roles.id = roleID")
             ->get();
        return $query->getResult();
    }

    public function addRole($newMemberID, $roleID)
    {
        $this->db->table('members_roles')->insert(['memberId'=>$newMemberID, 'roleId'=>$roleID]);
    }

    public function deleteRole($memberID, $roleID)
    {
        $this->db->table('members_roles')->delete(['memberId'=>$memberID, 'roleId'=>$roleID]);
    }

    // Email Delivery
    // ===============

    /**
     * Log the sending of a bulk email item.
     * Used by emailMerge.
     * @param unknown_type $email Email address of recipient
     * @param unknown_type $batchId ID of originating batch in email_batch table
     */
    public function logEmail($email, $batchId)
    {
        $this->db->table('email_log')
                 ->insert(array('email'=>$email, 'batchId'=>$batchId));
    }

    // Record info about a new batch of emails to be sent (maybe).
    // Not all batches will actually be sent -- user may cancel, and
    // the batch will remain until deleted by housekeeping.
    public function addEmailBatch($docId, $subject, $numRecipients)
    {
        $this->db->table('email_batch')->insert(array(
            'docId'     => $docId,
            'subject'   => $subject,
            'num_recipients' => $numRecipients)
        );
        return $this->db->insertID();
    }

    // Put an item in the queue of mail items to send as a batch
    // Returns the id of the inserted item (rarely useful).
    public function queueMailItem($batchId, $to, $subject, $body, $from = 'webmaster@ctc.org.nz')
    {
        $mailItem = array('batchId' => $batchId,
                          'to' => $to,
                          'from' => $from,
                          'subject' => $subject,
                          'body' => $body);
        $this->db->table('email_queue')->insert($mailItem);
        return $this->db->insertID();
    }

    // Gets the first unsent email with the given batchId.
    // Returns mailItem or false if none available.
    public function getNextMailItem($batchId)
    {
        $query = $this->db->table('email_queue')->getWhere(array('batchId' => $batchId), 1);
        if ($query->getNumRows() > 0) {
            return $query->getRow();
        } else {
            return false;
        }
    }

    // Gets a write lock on the mail queue to prevent multiple sessions
    // manipulating it.
    public function lockMailQueue()
    {
        $this->db->query('LOCK TABLES email_queue WRITE, email_log WRITE, email_batch WRITE');
    }

    // Release the write lock on the mail queue
    public function unlockMailQueue()
    {
        $this->db->query('UNLOCK TABLES');
    }

    // Query to return a list of confirmed batches
    public function incompleteBatches()
    {
        $query = $this->db->query("select id from email_batch where state='CONFIRMED'");
        $batches = array();
        foreach( $query->getResult() as $row) {
            $batches[] = $row->id;
        }
        return $batches;
    }

    // Confirm that the given batch of emails is ready to send.
    public function confirmMailBatch($batchId)
    {
        $query = $this->db->table('email_batch')
            ->where(array('id'=>$batchId))
            ->update(array('state' => 'CONFIRMED'));
    }

    public function deleteMailItem($id)
    {
        $this->db->table('email_queue')->delete(array('id'=>$id));
    }

    // Mark the given batch as DONE. Send an email to webmaster
    public function closeBatch($batchId)
    {
        $webmaster = 'webmaster@ctc.org.nz';
        $builder = $this->db->table('email_batch');
        $builder->where(array('id' => $batchId));
        $builder->update(array('state' => 'DONE'));
        $row = $builder->getWhere(array('id' => $batchId))->getRow();
        $message = "Batch email id {$row->id}, subject '{$row->subject}' ".
                "successfully sent to {$row->num_recipients} recipients.";
        sendEmail($webmaster, 'Christchurch Tramping Club', $webmaster,
                'Email Batch Sent', $message);
    }

    public function purgeOldMailItems()
    {
        $this->db->query(
           "DELETE email_queue
            FROM email_queue
            INNER JOIN email_batch
            ON email_batch.id = batchId
            WHERE DATEDIFF(NOW(), email_batch.timestamp) > 5
            ");
    }


    // INTERNAL SUPPORT FUNCTIONS
    // ==========================

    // Return an array of IDs of members who share this membershipId.
    // Should be either 1 or 2.
    private function getMemberIDs($membershipID)
    {
        $query = $this->db->query(
          "select id from members where membershipId = $membershipID");
        $rows = $query->getResultArray();
        $result = array();
        foreach ($rows as $row) {
            array_push($result, $row['id']);
        }
        return $result;
    }

    // Return the membership ID of the user with the given login.
    // Returns -1 if no such login.
    private function getIdFromLogin($login)
    {
        $query = $this->db->table('members')
                 ->select('id')
                 ->where('loginName', $login)
                 ->get();
        if ($query->getNumRows() != 1) {
            return -1;
        } else {
            return $query->getRow()->id;
        }
    }


    // Inserts a new entry of the given membership type in the 'memberships' table, return its id.
    // The parameter is an associative array of all the fields for which non-default
    // values are required.
    private function insertMembership($membershipType, $membershipData)
    {
        $query = $this->db->table('membership_types')->getWhere(['membershipTypeEnum' => $membershipType]);
        if ($query->getNumRows() != 1) {
            return false;
        }
        $row = $query->getRow();
        $membershipTypeID = $row->id;
        $membershipData['membershipTypeId'] = $membershipTypeID;
        $membershipData['userIdAdmin'] = session()->userID;
        $this->db->table('memberships')
                 ->set($membershipData)
                 ->set('dateOpenedAdmin','now()',false)
                 ->insert();
        $id = $this->db->insertID();
        return $id;
    }

    // Returns an associative (fieldName, fieldValue) array by pulling out a value
    // from the POST array for every given field (if it exists). The $includeEmpties parameter
    // controls whether fields left empty in the form are included. By
    // default they are (so that the user can clear non-empty fields).
    // The suffix is appended to each name when looking it up in the POST so that, e.g.,
    // can pull out all the member1 then all the member2 fields from the couple's form.

    // TODO: consider whether to include XSS filtering in the call to
    // $this->input->post. Could it mess up password processing?
    // Is is already messed up?!
    private function getFieldsFromRequest($request, $fields, $includeEmpties = true, $suffix = "", $overrides = array() )
    {
        $map = array();
        foreach ($fields as $field) {
            $fieldName = $field.$suffix;
            $value = '';
            if (array_key_exists($fieldName, $overrides)) {
                $value = $overrides[$fieldName];
            } else {
                $value = $request->getPostGet($fieldName);
            }
            if ($includeEmpties || $value != '') {
                $map[$field] = $value;
            }
        }
        return $map;
    }

    // Update the given (table, rowId) row from the given fields of the $_POST variable.
    // Returns the number of affected rows.
    private function updateTableFromPost($request, $tableName, $id, $postFields, $overrides = array())
    {
        $map = $this->getFieldsFromRequest($request, $postFields, true, '', $overrides);
        $this->db->table($tableName)->update($map, array('id'=>$id));
        $result = $this->db->affectedRows();
        return $result;
    }

    // Returns all the fields in the parameter array that don't end in Id or Admin
    private function filterNonModifiable($fields)
    {
        $result = array();
        foreach ($fields as $field) {
            if (!(strtoupper(substr($field,-2))=='ID' || strtoupper(substr($field,-5)) == 'ADMIN')) {
                array_push($result, $field);
            }
        }
        return $result;
    }

    private function recordMembershipUpdate($membershipId, $fieldName, $oldValue, $newValue, $notes='')
    {
        $this->db->table('membership_updates')->insert(
            array(
                'membershipId' => $membershipId,
                'fieldName' => $fieldName,
                'oldValue' => $oldValue,
                'newValue' => $newValue,
                'notes' => $notes,
                'userIdAdmin' => session()->userID
            )
        );
    }

    // Make an entry in the member_update table
    private function recordMemberUpdate($memberID,  $fieldName, $oldValue, $newValue, $notes='')
    {
        $this->db->table('member_updates')->insert(
            array(
                'memberID' => $memberID,
                'fieldName' => $fieldName,
                'oldValue' => $oldValue,
                'newValue' => $newValue,
                'notes' => $notes,
                'userIdAdmin' => session()->userID
            )
        );
    }

    private function recordSubsPaymentUpdate($subsPaymentId, $fieldName, $oldValue, $newValue)
    {
        $this->db->table('subs_payments_updates')->insert(
            array(
                'subsPaymentsId' => $subsPaymentId,
                'fieldName' => $fieldName,
                'oldValue' => $oldValue,
                'newValue' => $newValue,
                'notes' => '',
                'userIdAdmin' => session()->userID
            )
        );
    }

    // Returns the SQL function that converts Susan's format RESIGNED date to a MySQL format
    // I really hope I never have to write or touch this again, but I'm sticking it here for
    // safekeeping just in case.
    private function dateConvertFromSusan()
    {
        return "select ResignedDate, concat(mid(ResignedDate,locate('/',ResignedDate,locate('/',ResignedDate)+1)+1,4),".
         " '/', mid(ResignedDate, locate('/',ResignedDate)+1, 1+locate('/', ResignedDate, locate('/',ResignedDate)) -".
         " locate('/',ResignedDate)), '/', left(ResignedDate,locate('/',ResignedDate)-1))";
    }

    // Hash the password following the standard Joomla approach
    private function hashPassword($pass)
    {
        $saltChars  = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        $salt   = '';
        mt_srand(10000000*(double)microtime());
        for ($i = 0; $i < 16; $i++) {
            $salt .= $saltChars[mt_rand(0,61)];
        }
        $crypt = md5($pass.$salt);
        return $crypt.':'.$salt;
    }

    private function sendWelcomeEmail($id, $pass)
    {
        $memberData = $this->getMemberDataByMemberID($id);
        $memberData['pass'] = $pass;

        $userEmail = session()->email;
        $to = $memberData['primaryEmail'];
        if ($to == "") {
            $to = $userEmail;
            $subject = "CTC_DB_WARNING. Couldn't send welcome email to $loginName. No primary email";
            $cc = null;
        } else {
            $subject = 'Welcome to the CTC';
            $cc = $userEmail;
        }
        $welcomeMessage = $this->buildWelcomeMessage($memberData);
        helper('utilities');
        $name = session()->name;
        sendEmail($userEmail, $name, $to, $subject, $welcomeMessage, $cc);
    }

    // Builds the body of the CTC welcome message
    // from the form letter 'welcome' stored in the email_messages table.
    private function buildWelcomeMessage($memberData)
    {
        $result = $this->db->query("select message from email_messages where name='welcome'");
        $template = $result->getRow()->message;
        $bits = explode("$", $template);
        for ($i=1; $i < count($bits); $i += 2) {
            $bits[$i] = $memberData[$bits[$i]];
        }
        $message = implode($bits);
        return $message;
    }


    private function phoneNumsMatch($phone1, $phone2)
    {
        // True iff two phone numbers match. A leading '+' is converted
        // to 00. A single leading 0 is converted to 0064. All other numbers
        // have 00643 prepended. Both numbers are then stripped of non-numerics
        // and compared.
        return $this->normalisePhone($phone1) === $this->normalisePhone($phone2);
    }


    private function normalisePhone($ph)
    {
        if (strlen($ph) < 2) {
            return $ph; // Invalid. Ignore.
        }

        if ($ph[0] == '+') {
            $ph = '00' . substr($ph, 1);
        } elseif ($ph[0] == '0' && $ph[1] == '0') {
            // Nothing to do
        } elseif ($ph[0] == '0') {  // NZ local area code given
            $ph = '0064' . substr($ph, 1);
        } else {  // No area code. Assume 03
            $ph = '00643' . $ph;
        }
        return str_replace(array('-', ' '), '', $ph);
    }

}
